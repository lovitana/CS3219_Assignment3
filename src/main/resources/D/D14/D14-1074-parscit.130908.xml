<?xml version="1.0" encoding="UTF-8"?>
<algorithms version="110505">
<algorithm name="SectLabel" version="110505">
<variant no="0" confidence="0.002643">
<title confidence="0.991836">
Chinese Poetry Generation with Recurrent Neural Networks
</title>
<author confidence="0.996081">
Xingxing Zhang and Mirella Lapata
</author>
<affiliation confidence="0.999531">
Institute for Language, Cognition and Computation
School of Informatics, University of Edinburgh
</affiliation>
<address confidence="0.991804">
10 Crichton Street, Edinburgh EH8 9AB
</address>
<email confidence="0.997576">
x.zhang@ed.ac.uk, mlap@inf.ed.ac.uk
</email>
<sectionHeader confidence="0.994783" genericHeader="abstract">
Abstract
</sectionHeader>
<bodyText confidence="0.999974105263158">
We propose a model for Chinese poem
generation based on recurrent neural net-
works which we argue is ideally suited to
capturing poetic content and form. Our
generator jointly performs content selec-
tion (“what to say”) and surface realization
(“how to say”) by learning representations
of individual characters, and their com-
binations into one or more lines as well
as how these mutually reinforce and con-
strain each other. Poem lines are gener-
ated incrementally by taking into account
the entire history of what has been gen-
erated so far rather than the limited hori-
zon imposed by the previous line or lexical
n-grams. Experimental results show that
our model outperforms competitive Chi-
nese poetry generation systems using both
automatic and manual evaluation methods.
</bodyText>
<sectionHeader confidence="0.998783" genericHeader="introduction">
1 Introduction
</sectionHeader>
<bodyText confidence="0.999790833333333">
Classical poems are a significant part of China’s
cultural heritage. Their popularity manifests itself
in many aspects of everyday life, e.g., as a means
of expressing personal emotion, political views,
or communicating messages at festive occasions
as well as funerals. Amongst the many differ-
ent types of classical Chinese poetry, quatrain and
regulated verse are perhaps the best-known ones.
Both types of poem must meet a set of structural,
phonological, and semantic requirements, render-
ing their composition a formidable task left to the
very best scholars.
An example of a quatrain is shown in Table 1.
Quatrains have four lines, each five or seven char-
acters long. Characters in turn follow specific
phonological patterns, within each line and across
lines. For instance, the final characters in the sec-
ond, fourth and (optionally) first line must rhyme,
</bodyText>
<listItem confidence="0.7701994">
44 Z
Missing You
� s I k 19, (*ZPPZ)
Red berries born in the warm southland.
4L A,- &amp; JL A? (PPZZP)
</listItem>
<bodyText confidence="0.9963352">
How many branches flush in the spring?
All 9 -4 441 (*PPZZ)
Take home an armful, for my sake,
.til #_4p -- (*ZZPP)
As a symbol of our love.
</bodyText>
<tableCaption confidence="0.654207">
Table 1: An example of a 5-char quatrain ex-
</tableCaption>
<bodyText confidence="0.998291923076923">
hibiting one of the most popular tonal patterns.
The tone of each character is shown at the end of
each line (within parentheses); P and Z are short-
hands for Ping and Ze tones, respectively; * indi-
cates that the tone is not fixed and can be either.
Rhyming characters are shown in boldface.
whereas there are no rhyming constraints for the
third line. Moreover, poems must follow a pre-
scribed tonal pattern. In traditional Chinese, ev-
ery character has one tone, Ping (level tone) or Ze
(downward tone). The poem in Table 1 exempli-
fies one of the most popular tonal patterns (Wang,
2002). Besides adhering to the above formal crite-
ria, poems must exhibit concise and accurate use
of language, engage the reader/hearer, stimulate
their imagination, and bring out their feelings.
In this paper we are concerned with generat-
ing traditional Chinese poems automatically. Al-
though computers are no substitute for poetic cre-
ativity, they can analyze very large online text
repositories of poems, extract statistical patterns,
maintain them in memory and use them to gen-
erate many possible variants. Furthermore, while
amateur poets may struggle to remember and ap-
ply formal tonal and structural constraints, it is rel-
atively straightforward for the machine to check
</bodyText>
<page confidence="0.971899">
670
</page>
<note confidence="0.9103135">
Proceedings of the 2014 Conference on Empirical Methods in Natural Language Processing (EMNLP), pages 670–680,
October 25-29, 2014, Doha, Qatar. c�2014 Association for Computational Linguistics
</note>
<bodyText confidence="0.999934023809524">
whether a candidate poem conforms to these re-
quirements. Poetry generation has received a fair
amount of attention over the past years (see the
discussion in Section 2), with dozens of computa-
tional systems written to produce poems of vary-
ing sophistication. Beyond the long-term goal of
building an autonomous intelligent system capa-
ble of creating meaningful poems, there are po-
tential short-term applications for computer gen-
erated poetry in the ever growing industry of elec-
tronic entertainment and interactive fiction as well
as in education. An assistive environment for
poem composition could allow teachers and stu-
dents to create poems subject to their require-
ments, and enhance their writing experience.
We propose a model for Chinese poem genera-
tion based on recurrent neural networks. Our gen-
erator jointly performs content selection (“what
to say”) and surface realization (“how to say”).
Given a large collection of poems, we learn repre-
sentations of individual characters, and their com-
binations into one or more lines as well as how
these mutually reinforce and constrain each other.
Our model generates lines in a poem probabilis-
tically: it estimates the probability of the current
line given the probability of all previously gener-
ated lines. We use a recurrent neural network to
learn the representations of the lines generated so
far which in turn serve as input to a recurrent lan-
guage model (Mikolov et al., 2010; Mikolov et al.,
2011b; Mikolov et al., 2011a) which generates the
current line. In contrast to previous approaches
(Greene et al., 2010; Jiang and Zhou, 2008), our
generator makes no Markov assumptions about the
dependencies of the words within a line and across
lines.
We evaluate our approach on the task of qua-
train generation (see Table 1 for a human-written
example). Experimental results show that our
model outperforms competitive Chinese poetry
generation systems using both automatic and man-
ual evaluation methods.
</bodyText>
<sectionHeader confidence="0.999809" genericHeader="related work">
2 Related Work
</sectionHeader>
<bodyText confidence="0.9999575">
Automated poetry generation has been a popular
research topic over the past decades (see Colton
et al. (2012) and the references therein). Most ap-
proaches employ templates to construct poems ac-
cording to a set of constraints (e.g., rhyme, me-
ter, stress, word frequency) in combination with
corpus-based and lexicographic resources. For
example, the Haiku poem generator presented in
Wu et al. (2009) and Tosa et al. (2008) produces
poems by expanding user queries with rules ex-
tracted from a corpus and additional lexical re-
sources. Netzer et al. (2009) generate Haiku
with Word Association Norms, Agirrezabal et
al. (2013) compose Basque poems using patterns
based on parts of speech and WordNet (Fellbaum,
1998), and Oliveira (2012) presents a generation
algorithm for Portuguese which leverages seman-
tic and grammar templates.
A second line of research uses genetic algo-
rithms for poem generation (Manurung, 2003;
Manurung et al., 2012; Zhou et al., 2010). Ma-
nurung et al. (2012) argue that at a basic level
all (machine-generated) poems must satisfy the
constraints of grammaticality (i.e., a poem must
syntactically well-formed), meaningfulness (i.e., a
poem must convey a message that is meaningful
under some interpretation) and poeticness (i.e., a
poem must exhibit features that distinguishes it
from non-poetic text, e.g., metre). Their model
generates several candidate poems and then uses
stochastic search to find those which are grammat-
ical, meaningful, and poetic.
A third line of research draws inspiration from
statistical machine translation (SMT) and re-
lated text-generation applications such as sum-
marization. Greene et al. (2010) infer meters
(stressed/unstressed syllable sequences) from a
corpus of poetic texts which they subsequently
use for generation together with a cascade of
weighted finite-state transducers interpolated with
IBM Model 1. Jiang and Zhou (2008) generate
Chinese couplets (two line poems) using a phrase-
based SMT approach which translates the first line
to the second line. He et al. (2012) extend this al-
gorithm to generate four-line quatrains by sequen-
tially translating the current line from the previous
one. Yan et al. (2013) generate Chinese quatrains
based on a query-focused summarization frame-
work. Their system takes a few keywords as input
and retrieves the most relevant poems from a cor-
pus collection. The retrieved poems are segmented
into their constituent terms which are then grouped
into clusters. Poems are generated by iteratively
selecting terms from clusters subject to phonolog-
ical, structural, and coherence constraints.
Our approach departs from previous work in
two important respects. Firstly, we model the tasks
of surface realization and content selection jointly
</bodyText>
<page confidence="0.992045">
671
</page>
<figure confidence="0.999695263157895">
First line
generation
Next line
generation
Keywords
%(spring)
59(lute)
‰(drunk)
Line 4
Line 3
ShiXueHanYing
spring
lute drunk
Line 2
Candidate lines
91 A A q �
� � �
Line 1
...
</figure>
<figureCaption confidence="0.933561666666667">
Figure 1: Poem generation with keywords spring, lute, and drunk. The keywords are expanded into
phrases using a poetic taxonomy. Phrases are then used to generate the first line. Following lines are
generated by taking into account the representations of all previously generated lines.
</figureCaption>
<bodyText confidence="0.999892333333333">
using recurrent neural networks. Structural, se-
mantic, and coherence constraints are captured
naturally in our framework, through learning the
representations of individual characters and their
combinations. Secondly, generation proceeds by
taking into account multi-sentential context rather
than the immediately preceding sentence. Our
work joins others in using continuous representa-
tions to express the meaning of words and phrases
(Socher et al., 2012; Mikolov et al., 2013) and
how these may be combined in a language mod-
eling context (Mikolov and Zweig, 2012). More
recently, continuous translation models based on
recurrent neural networks have been proposed as
a means to map a sentence from the source lan-
guage to sentences in the target language (Auli
et al., 2013; Kalchbrenner and Blunsom, 2013).
These models are evaluated on the task of rescor-
ing n-best lists of translations. We use neural net-
works more directly to perform the actual poem
generation task.
</bodyText>
<sectionHeader confidence="0.977828" genericHeader="method">
3 The Poem Generator
</sectionHeader>
<bodyText confidence="0.999979742857143">
As common in previous work (Yan et al., 2013;
He et al., 2012) we assume that our generator op-
erates in an interactive context. Specifically, the
user supplies keywords (e.g., spring, lute, drunk)
highlighting the main concepts around which the
poem will revolve. As illustrated in Figure 1, our
generator expands these keywords into a set of re-
lated phrases. We assume the keywords are re-
stricted to those attested in the ShiXueHanYing po-
etic phrase taxonomy (He et al., 2012; Yan et al.,
2013). The latter contains 1,016 manual clusters
of phrases (Liu, 1735); each cluster is labeled with
a keyword id describing general poem-worthy top-
ics. The generator creates the first line of the poem
based on these keywords. Subsequent lines are
generated based on all previously generated lines,
subject to phonological (e.g., admissible tonal pat-
terns) and structural constraints (e.g., whether the
quatrain is five or seven characters long).
To create the first line, we select all phrases
corresponding to the user’s keywords and gener-
ate all possible combinations satisfying the tonal
pattern constraints. We use a language model to
rank the generated candidates and select the best-
ranked one as the first line in the poem. In im-
plementation, we employ a character-based recur-
rent neural network language model (Mikolov et
al., 2010) interpolated with a Kneser-Ney trigram
and find the n-best candidates with a stack de-
coder (see Section 3.5 for details). We then gen-
erate the second line based on the first one, the
third line based on the first two lines, and so on.
Our generation model computes the probability
of line Si+1 = w1,w2,...,wm, given all previously
generated lines S1:i(i ≥ 1) as:
</bodyText>
<equation confidence="0.998735">
P(wj+1|w1:j,S1:i) (1)
</equation>
<bodyText confidence="0.9998961">
Equation (1), decomposes P(Si+1|S1:i) as the prod-
uct of the probability of each character wj in
the current line given all previously generated
characters w1:j−1 and lines S1:i. This means
that P(Si+1|S1:i) is sensitive to previously gener-
ated content and currently generated characters.
The estimation of the term P(wj+1|w1:j,S1:i)
lies at the heart of our model. We learn repre-
sentations for S1:i, the context generated so far,
using a recurrent neural network whose output
</bodyText>
<equation confidence="0.99640325">
P(Si+1|S1:i) =
m−1
∏
j=1
</equation>
<page confidence="0.984347">
672
</page>
<bodyText confidence="0.999929588235294">
serves as input to a second recurrent neural net-
work used to estimate P(wj+1|w1:j,S1:i). Figure 2
illustrates the generation process for the (j + 1)th
character wj+1 in the (i + 1)th line Si+1. First,
lines S1:i are converted into vectors v1:i with a
convolutional sentence model (CSM; described in
Section 3.1). Next, a recurrent context model
(RCM; see Section 3.2) takes v1:i as input and
outputs uij , the representation needed for gener-
ating wj+1 ∈ Si+1. Finally, u1i ,u2i ,...,uj i and the
first j characters w1: j in line Si+1 serve as input to
a recurrent generation model (RGM) which esti-
mates P(wj+1 = k|w1: j,S1:i) with k ∈ V, the prob-
ability distribution of the (j + 1)th character over
all words in the vocabulary V. More formally, to
estimate P(wj+1|w1: j,S1:i) in Equation (1), we ap-
ply the following procedure:
</bodyText>
<equation confidence="0.981129">
vi = CSM(Si) (2a)
uij = RCM(v1:i, j) (2b)
P(wj+1|w1: j,S1:i) = RGM(w1: j+1,u1: j
i ) (2c)
</equation>
<bodyText confidence="0.999999">
We obtain the probability of the (i + 1)th sen-
tence P(Si+1|S1:i), by running the RGM in (2c)
above m −1 times (see also Equation (1)). In the
following, we describe how the different compo-
nents of our model are obtained.
</bodyText>
<subsectionHeader confidence="0.998504">
3.1 Convolutional Sentence Model (CSM)
</subsectionHeader>
<bodyText confidence="0.966578971428572">
The CSM converts a poem line into a vector. In
principle, any model that produces vector-based
representations of phrases or sentences could be
used (Mitchell and Lapata, 2010; Socher et al.,
2012). We opted for the convolutional sentence
model proposed in Kalchbrenner and Blunsom
(2013) as it is n-gram based and does not make
use of any parsing, POS-tagging or segmentation
tools which are not available for Chinese poems.
Their model computes a continuous representation
for a sentence by sequentially merging neighbor-
ing vectors (see Figure 3).
Let V denote the character vocabulary in our
corpus; L ∈ Rq×|V |denotes a character embed-
ding matrix whose columns correspond to char-
acter vectors (q represents the hidden unit size).
Such vectors can be initialized randomly or ob-
tained via a training procedure (Mikolov et al.,
2013). Let w denote a character with index k;
e(w) ∈ R|V|×1 is a vector with zero in all positions
except e(w)k = 1; Tl ∈ Rq×Nl is the sentence rep-
resentation in the lth layer, where Nl is the num-
ber of columns in the lth layer (Nl = 1 in the
Figure 2: Generation of the (j + 1)th charac-
ter wj+1 in the (i + 1)th line Si+1. The recur-
rent context model (RCM) takes i lines as in-
put (represented by vectors v1,...,vi) and cre-
ates context vectors for the recurrent generation
model (RGM). The RGM estimates the probabil-
ity P(wj+1|w1: j,S1:i).
top layer); Cl,n ∈ Rq×n is an array of weight ma-
trices which compress neighboring n columns in
the lth layer to one column in the (l + 1)th layer.
Given a sentence S = w1,w2,...,wm, the first layer
is represented as:
</bodyText>
<equation confidence="0.99462">
(3)
N1 = m
The (l + 1)th layer is then computed as follows:
Nl+1 = Nl − n + 1 (4)
1 ≤ j ≤ Nl+1
</equation>
<bodyText confidence="0.999965">
where Tl is the representation of the previous
layer l, Cl,n a weight matrix, O element-wise vec-
tor product, and σ a non-linear function. We com-
press two neighboring vectors in the first two lay-
ers and three neighboring vectors in the remaining
layers. Specifically, for quatrains with seven char-
acters, we use C1,2, C2,2, C3,3, C4,3 to merge vec-
tors in each layer (see Figure 3); and for quatrains
with five characters we use C1,2, C2,2, C3,3.
</bodyText>
<figure confidence="0.736979">
RGM
1-of-N encoding of
wj=(0,... ,1,... ,0)
P(wj+1|w1:j,S1:i)
rj
rj−1
RCM
vi
hi
hi−1
uj
</figure>
<equation confidence="0.712600166666667">
i
uki (k =6 j)
T1 = [L·e(w1),L·e(w2),...,L·e(wm)]
Tl+1 = σ( n Tl
:,j ∑ :,j+i−1 �Cl,n
i=1 :,i )
</equation>
<page confidence="0.965175">
673
</page>
<figureCaption confidence="0.983472">
Figure 3: Convolutional sentence model for 7-char
</figureCaption>
<bodyText confidence="0.8905198">
quatrain. The first layer has seven vectors, one
for each character. Two neighboring vectors are
merged to one vector in the second layer with
weight matrix C1,2. In other layers, either two or
three neighboring vectors are merged.
</bodyText>
<subsectionHeader confidence="0.983561">
3.2 Recurrent Context Model (RCM)
</subsectionHeader>
<bodyText confidence="0.999986411764706">
The RCM takes as input the vectors representing
the i lines generated so far and reduces them to a
single context vector which is then used to gener-
ate the next character (see Figure 2). We compress
the i previous lines to one vector (the hidden layer)
and then decode the compressed vector to different
character positions in the current line. The output
layer consists thus of several vectors (one for each
position) connected together. This way, different
aspects of the context modulate the generation of
different characters.
Let v1,...,vi (vi ∈ Rq×1) denote the vectors of
the previous i lines; hi ∈ Rq×1 is their compressed
representation (hidden layer) which is obtained
with matrix M ∈ Rq×2q; matrix Uj decodes hi to
uji ∈ Rq×1 in the (i + 1)th line. The computation
of the RCM proceeds as follows:
</bodyText>
<equation confidence="0.99911">
h0 = 0
hi = a Vi(M • )
[hi−1]
uji = a(Uj · hi) 1 ≤ j ≤ m −1
</equation>
<bodyText confidence="0.999859714285714">
where a is a non-linear function such as sigmoid
and m the line length. Advantageously, lines in
classical Chinese poems have a fixed length of five
or seven characters. Therefore, the output layer of
the recurrent context model only needs two weight
matrices (one for each length) and the number of
parameters still remains tractable.
</bodyText>
<subsectionHeader confidence="0.995368">
3.3 Recurrent Generation Model (RGM)
</subsectionHeader>
<bodyText confidence="0.99986347368421">
As shown in Figure 2, the RGM estimates the
probability distribution of the next character (over
the entire vocabulary) by taking into account the
context vector provided by the RCM and the
1-of-N encoding of the previous character. The
RGM is essentially a recurrent neural network lan-
guage model (Mikolov et al., 2010) with an aux-
iliary input layer, i.e., the context vector from
the RCM. Similar strategies for encoding addi-
tional information have been adopted in related
language modeling and machine translation work
(Mikolov and Zweig, 2012; Kalchbrenner and
Blunsom, 2013; Auli et al., 2013).
Let Si+1 = w1,w2,...,wm denote the line
to be generated. The RGM must esti-
mate P(wj+1|w1:j,S1:i), however, since the first
i lines have been encoded in the context vector uji ,
we compute P(wj+1|w1:j,uji ) instead. Therefore,
the probability P(Si+1|S1:i) becomes:
</bodyText>
<equation confidence="0.855996">
P(wj+1|w1:j,uji ) (6)
</equation>
<bodyText confidence="0.999970133333333">
Let |V |denote the size of the character vocabu-
lary. The RGM is specified by a number of ma-
trices. Matrix H ∈ Rq×q (where q represents the
hidden unit size) transforms the context vector to
a hidden representation; matrix X ∈ Rq×|V |trans-
forms a character to a hidden representation, ma-
trix R ∈ Rq×q implements the recurrent transfor-
mation and matrix Y ∈ R|V|×q decodes the hidden
representation to weights for all words in the vo-
cabulary. Let w denote a character with index k
in V; e(w) ∈ R|V|×1 represents a vector with zero
in all positions except e(w)k = 1, rj is the hidden
layer of the RGM at step j, and yj+1 the output of
the RGM, again at step j. The RGM proceeds as
follows:
</bodyText>
<equation confidence="0.999809666666667">
r0 = 0
rj = a(R·rj−1 +X ·e(wj)+H ·uji )
yj+1 = Y · rj
</equation>
<bodyText confidence="0.98989">
where a is a nonlinear function (e.g., sigmoid).
</bodyText>
<figure confidence="0.973100916666667">
C4,3
C1,2
C3,3
C2,2
A * ;&apos;� 4 A&gt; )II
Far off I watch the waterfall plunge to the
long river.
(5)
P(Si+1|S1:i) =
m−1
H
j=1
</figure>
<page confidence="0.992912">
674
</page>
<bodyText confidence="0.999649">
The probability of the (j + 1)th word given the
previous j words and the previous i lines is esti-
mated by a softmax function:
</bodyText>
<equation confidence="0.9967765">
exp(yj+1,k)
P(wj+1 = k|w1 :j, uj) = (8)
∑|V|
k=1 exp(yj+1,k)
</equation>
<bodyText confidence="0.999904">
We obtain P(Si+1|S1:i) by multiplying all the terms
in the right hand-side of Equation (6).
</bodyText>
<subsectionHeader confidence="0.940411">
3.4 Training
</subsectionHeader>
<bodyText confidence="0.999620327586207">
The objective for training is the cross entropy er-
rors of the predicted character distribution and the
actual character distribution in our corpus. An
l2 regularization term is also added to the objec-
tive. The model is trained with back propagation
through time (Rumelhart et al., 1988) with sen-
tence length being the time step. The objective
is minimized by stochastic gradient descent. Dur-
ing training, the cross entropy error in the output
layer of the RGM is back-propagated to its hid-
den and input layers, then to the RCM and finally
to the CSM. The same number of hidden units
(q = 200) is used throughout (i.e., in the RGM,
RCM, and CSM). In our experiments all param-
eters were initialized randomly, with the excep-
tion of the word embedding matrix in the CSM
which was initialized with word2vec embeddings
(Mikolov et al., 2013) obtained from our poem
corpus (see Section 4 for details on the data we
used).
To speed up training, we employed word-
classing (Mikolov et al., 2011b). To compute the
probability of a character, we estimate the proba-
bility of its class and then multiply it by the proba-
bility of the character conditioned on the class. In
our experiments we used 82 (square root of |V|)
classes which we obtained by applying hierarchi-
cal clustering on character embeddings. This strat-
egy outperformed better known frequency-based
classing methods (Zweig and Makarychev, 2013)
on our task.
Our poem generator models content selection
and lexical choice and their interaction, but does
not have a strong notion of local coherence,
as manifested in poetically felicitous line-to-line
transitions. In contrast, machine translation mod-
els (Jiang and Zhou, 2008) have been particu-
larly successful at generating adjacent lines (cou-
plets). To enhance coherence, we thus interpolate
our model with two machine translation features
(i.e., inverted phrase translation model feature and
inverted lexical weight feature). Also note, that
in our model surface generation depends on the
last observed character and the state of the hidden
layer before this observation. This way, there is no
explicitly defined context, and history is captured
implicitly by the recurrent nature of the model.
This can be problematic for our texts which must
obey certain stylistic conventions and sound po-
etic. In default of a better way of incorporating
poeticness into our model, we further interpolate it
with a language model feature (i.e., a Kneser-Ney
trigram model).
Throughout our experiments, we use the
RNNLM toolkit to train the character-based recur-
rent neural network language model (Mikolov et
al., 2010). Kneser-Ney n-grams were trained with
KenLM (Heafield, 2011).
</bodyText>
<subsectionHeader confidence="0.826428">
3.5 Decoding
</subsectionHeader>
<bodyText confidence="0.999989307692308">
Our decoder is a stack decoder similar to Koehn
et al. (2003). In addition, it implements the tonal
pattern and rhyming constraints necessary for gen-
erating well-formed Chinese quatrains. Once the
first line in a poem is generated, its tonal pattern
is determined. During decoding, phrases violat-
ing this pattern are ignored. As discussed in Sec-
tion 1, the final characters of the second and the
fourth lines must rhyme. We thus remove during
decoding fourth lines whose final characters do not
rhyme with the second line. Finally, we use MERT
training (Och, 2003) to learn feature weights for
the decoder.
</bodyText>
<sectionHeader confidence="0.99741" genericHeader="method">
4 Experimental Design
</sectionHeader>
<bodyText confidence="0.9997525">
Data We created a corpus of classical Chinese
poems by collating several online resources: Tang
Poems, Song Poems, Song Ci, Ming Poems, Qing
Poems, and Tai Poems. The corpus consists
of 284,899 poems in total. 78,859 of these are
quatrains and were used for training and evalu-
ating our model.1 Table 2 shows the different
partitions of this dataset (POEMLM) into train-
ing (QTRAIN)2, validation (QVALID) and testing
(QTEST). Half of the poems in QVALID and
QTEST are 5-char quatrains and the other half
are 7-char quatrains. All poems except QVALID
</bodyText>
<footnote confidence="0.9998692">
1The data used in our experiments can be downloaded
from http://homepages.inf.ed.ac.uk/mlap/index.
php?page=resources.
2Singleton characters in QTRAIN (6,773 in total) were re-
placed by &lt;R&gt; to reduce data sparsity.
</footnote>
<page confidence="0.996153">
675
</page>
<table confidence="0.936906888888889">
Poems Lines Characters
QTRAIN 74,809 299,236 2,004,460
QVALID 2,000 8,000 48,000
QTEST 2,050 8,200 49,200
POEMLM 280,849 2,711,034 15,624,283
Models Perplexity
KN5 172
RNNLM 145
RNNPG 93
</table>
<tableCaption confidence="0.849515">
Table 3: Perplexities for different models.
Table 2: Dataset partitions of our poem corpus.
</tableCaption>
<bodyText confidence="0.999883304347826">
and QTEST were used for training the character-
based language models (see row POEMLM in Ta-
ble 2). We also trained word2vec embeddings on
POEMLM. In our experiments, we generated qua-
trains following the eight most popular tonal pat-
terns according to Wang (2002).
Perplexity Evaluation Evaluation of machine-
generated poetry is a notoriously difficult task.
Our evaluation studies were designed to assess
Manurung et al.’s (2012) criteria of grammatical-
ity, meaningfulness, and poeticness. As a san-
ity check, we first measured the perplexity of our
model with respect to the goldstandard. Intu-
itively, a better model should assign larger proba-
bility (and therefore lower perplexity) to goldstan-
dard poems.
BLEU-based Evaluation We also used BLEU
to evaluate our model’s ability to generate the sec-
ond, third and fourth line given previous goldstan-
dard lines. A problematic aspect of this evalu-
ation is the need for human-authored references
(for a partially generated poem) which we do not
have. We obtain references automatically follow-
ing the method proposed in He et al. (2012). The
main idea is that if two lines share a similar topic,
the lines following them can be each other’s ref-
erences. Let A and B denote two adjacent lines
in a poem, with B following A. Similarly, let line
B0 follow line A0 in another poem. If lines A and
A0 share some keywords in the same cluster in the
Shixuehanying taxonomy, then B and B0 can be
used as references for both A and A0. We use this
algorithm on the Tang Poems section of our corpus
to build references for poems in the QVALID and
QTEST data sets. Poems in QVALID (with auto-
generated references) were used for MERT train-
ing and Poems in QTEST (with auto-generated ref-
erences) were used for BLEU evaluation.
ments. Specifically, we invited 30 experts3 on
Chinese poetry to assess the output of our gen-
erator (and comparison systems). These experts
were asked to rate the poems using a 1–5 scale on
four dimensions: fluency (is the poem grammati-
cal and syntactically well-formed?), coherence (is
the poem thematically and logically structured?),
meaningfulness (does the poem convey a mean-
ingful message to the reader?) and poeticness
(does the text display the features of a poem?).
We also asked our participants to evaluate system
outputs by ranking the generated poems relative to
each other as a way of determining overall poem
quality (Callison-Burch et al., 2012).
Participants rated the output of our model and
three comparison systems. These included He et
al.’s (2012) SMT-based model (SMT), Yan et al.’s
(2013) summarization-based system (SUM), and
a random baseline which creates poems by ran-
domly selecting phrases from the Shixuehanying
taxonomy given some keywords as input. We
also included human written poems whose content
matched the input keywords. All systems were
provided with the same keywords (i.e., the same
cluster names in the ShiXueHanYing taxonomy).
In order to compare all models on equal footing,
we randomly sampled 30 sets of keywords (with
three keywords in each set) and generated 30 qua-
trains for each system according to two lengths,
namely 5-char and 7-char. Overall, we obtained
ratings for 300 (5×30×2) poems.
</bodyText>
<sectionHeader confidence="0.998281" genericHeader="evaluation">
5 Results
</sectionHeader>
<bodyText confidence="0.975795">
The results of our perplexity evaluation are sum-
marized in Table 3. We compare our RNN-based
poem generator (RNNPG) against Mikolov’s
(2010) recurrent neural network language model
(RNNLM) and a 5-gram language model with
Kneser-Ney smoothing (KN5). All models were
trained on QTRAIN and tuned on QVALID. The
perplexities were computed on QTEST. Note that
Human Evaluation Finally, we also evaluated
the generated poems by eliciting human judg-
</bodyText>
<footnote confidence="0.657970666666667">
327 participants were professional or amateur poets and
three were Chinese literature students who had taken at least
one class on Chinese poetry composition.
</footnote>
<page confidence="0.995394">
676
</page>
<table confidence="0.99959775">
Models 1 → 2 2 → 3 3 → 4 Average
5-char 7-char 5-char 7-char 5-char 7-char 5-char 7-char
SMT 0.0559 0.0906 0.0410 0.1837 0.0547 0.1804 0.0505 0.1516
RNNPG 0.0561 0.1868 0.0515 0.2102 0.0572 0.1800 0.0549 0.1923
</table>
<tableCaption confidence="0.998772">
Table 4: BLEU-2 scores on 5-char and 7-char quatrains. Given i goldstandard lines, BLEU-2 scores are
computed for the next (i + 1)th lines.
</tableCaption>
<table confidence="0.999863714285714">
Models Fluency Coherence Meaning Poeticness Rank
5-char 7-char 5-char 7-char 5-char 7-char 5-char 7-char 5-char 7-char
Random 2.52 2.18 2.22 2.16 2.02 1.93 1.77 1.71 0.31 0.26
SUM 1.97 1.91 2.08 2.33 1.84 1.98 1.66 1.73 0.25 0.22
SMT 2.81 3.01 2.47 2.76 2.33 2.73 2.08 2.36 0.43 0.53
RNNPG 4.01&apos;&apos; 3.44&apos; 3.18&apos;&apos; 3.12&apos; 3.20&apos;&apos; 3.02 2.80&apos;&apos; 2.68&apos; 0.73&apos; &apos; 0.64&apos;
Human 4.31+ 4.19++ 3.81++ 4.00++ 3.61+ 3.91++ 3.29++ 3.49++ 0.79 0.84++
</table>
<tableCaption confidence="0.939244">
Table 5: Mean ratings elicited by humans on 5-char and 7-char quatrains. Diacritics ** (p &lt; 0.01)
and * (p &lt; 0.05) indicate our model (RNNPG) is significantly better than all other systems except Human.
Diacritics ++ (p &lt; 0.01) and + (p &lt; 0.05) indicate Human is significantly better than all other systems.
</tableCaption>
<bodyText confidence="0.993566390625">
the RNNPG estimates the probability of a poem
line given at least one previous line. Therefore, the
probability of a quatrain assigned by the RNNPG
is the probability of the last three lines. For a fair
comparison, RNNLM and KN5 only leverage the
last three lines of each poem during training, vali-
dation and testing. The results in Table 3 indicate
that the generation ability of the RNNPG is better
than KN5 and RNNLM. Note that this perplexity-
style evaluation is not possible for models which
cannot produce probabilities for gold standard po-
ems. For this reason, other related poem gener-
ators (Yan et al., 2013; He et al., 2012) are not
included in the table.
The results of our evaluation using BLEU-2 are
summarized in Table 4. Here, we compare our
system against the SMT-based poem generation
model of He et al. (2012).4 Their system is a
linear combination of two translation models (one
with five features and another one with six). Our
model uses three of their features, namely the in-
verted phrase translation model feature, the lexical
weight feature, and a Kneser-Ney trigram feature.
Unfortunately, it is not possible to evaluate Yan
et al.’s (2013) summarization-based system with
BLEU, as it creates poems as a whole and there is
no obvious way to generate next lines with their
4Our re-implementation of their system delivered very
similar scores to He et al. (2012). For example, we ob-
tained an average BLEU-1 of 0.167 for 5-char quatrains and
0.428 for 7-char quatrains compared to their reported scores
of 0.141 and 0.380, respectively.
algorithm. The BLEU scores in Table 4 indicate
that, given the same context lines, the RNNPG is
better than SMT at generating what to say next.
BLEU scores should be, however, viewed with
some degree of caution. Aside from being an ap-
proximation of human judgment (Callison-Burch
et al., 2012), BLEU might be unnecessarily con-
servative for poem composition which by its very
nature is a creative endeavor.
The results of our human evaluation study are
shown in Table 5. Each column reports mean rat-
ings for a different dimension (e.g., fluency, co-
herence). Ratings for 5-char and 7-char quatrains
are shown separately. The last column reports
rank scores for each system (Callison-Burch et al.,
2012). In a ranked list of N items (N = 5 here), the
score of the ith ranked item is (N−i)
(N−1). The numer-
ator indicates how many times a systems won in
pairwise comparisons, while the denominator nor-
malizes the score.
With respect to 5-char quatrains, RNNPG is
significantly better than Random, SUM and SMT
on fluency, coherence, meaningfulness, poeticness
and ranking scores (using a t-test). On all dimen-
sions, human-authored poems are rated as signif-
icantly better than machine-generated ones, with
the exception of overall ranking. Here, the dif-
ference between RNNPG and Human is not sig-
nificant. We obtain similar results with 7-char
quatrains. In general, RNNPG seems to perform
better on the shorter poems. The mean ratings
</bodyText>
<page confidence="0.96279">
677
</page>
<bodyText confidence="0.989391375">
ftA--,:L, �IWI)KA-R*-,
Egrets stood, peeping fishes. Budding branches are full of romance.
�����. *k#t)T°T..A,.
Water was still, reflecting mountains. Plum blossoms are invisible but adorable.
�����, h fig,
The wind went down by nightfall, With the east wind comes Spring.
0)]Ato*. �������.
as the moon came up by the tower. Where on earth do I come from?
</bodyText>
<tableCaption confidence="0.966943">
Table 6: Example output produced by our model (RNNPG).
</tableCaption>
<bodyText confidence="0.999989791666667">
are higher and the improvements over other sys-
tems are larger. Also notice, that the score mar-
gins between the human- and machine-written po-
ems become larger for 7-char quatrains. This in-
dicates that the composition of 7-char quatrains is
more difficult compared to 5-char quatrains. Ta-
ble 6 shows two example poems (5-char and 7-
char) produced by our model which received high
scores with respect to poeticness.
Interestingly, poems generated by SUM5 are
given ratings similar to Random. In fact SUM
is slightly worse (although not significantly) than
Random on all dimensions, with the exception of
coherence. In the human study reported in Yan et
al. (2013), SUM is slightly better than SMT. There
are several reasons for this discrepancy. We used
a more balanced experimental design: all systems
generated poems from the same keywords which
were randomly chosen. We used a larger dataset
to train the SMT model compared to Yan et al.
(284,899 poems vs 61,960). The Random baseline
is not a straw-man; it selects phrases from a taxon-
omy of meaningful clusters edited by humans and
closely related to the input keywords.
</bodyText>
<sectionHeader confidence="0.999312" genericHeader="conclusions">
6 Conclusions
</sectionHeader>
<bodyText confidence="0.998765181818182">
In this paper we have presented a model for Chi-
nese poem generation based on recurrent neural
networks. Our model jointly performs content se-
lection and surface realization by learning repre-
sentations of individual characters and their com-
binations within and across poem lines. Previous
work on poetry generation has mostly leveraged
contextual information of limited length (e.g., one
sentence). In contrast, we introduced two recur-
rent neural networks (the recurrent context model
and recurrent generation model) which naturally
</bodyText>
<footnote confidence="0.894234666666667">
5We made a good-faith effort to re-implement their poem
generation system. We are grateful to Rui Yan for his help
and technical advice.
</footnote>
<bodyText confidence="0.999834772727273">
capture multi-sentential content. Experimental re-
sults show that our model yields high quality po-
ems compared to the state of the art. Perhaps un-
surprisingly, our human evaluation study revealed
that machine-generated poems lag behind human-
generated ones. It is worth bearing in mind that
poetry composition is a formidable task for hu-
mans, let alone machines. And that the poems
against which our output was compared have been
written by some of the most famous poets in Chi-
nese history!
Avenues for future work are many and varied.
We would like to generate poems across differ-
ent languages and genres (e.g., Engish sonnets or
Japanese haiku). We would also like to make the
model more sensitive to line-to-line transitions and
stylistic conventions by changing its training ob-
jective to a combination of cross-entropy error and
BLEU score. Finally, we hope that some of the
work described here might be of relevance to other
generation tasks such as summarization, concept-
to-text generation, and machine translation.
</bodyText>
<sectionHeader confidence="0.997562" genericHeader="acknowledgments">
Acknowledgments
</sectionHeader>
<bodyText confidence="0.99999">
We would like to thank Eva Halser for valuable
discussions on the machine translation baseline.
We are grateful to the 30 Chinese poetry experts
for participating in our rating study. Thanks to
Gujing Lu, Chu Liu, and Yibo Wang for their help
with translating the poems in Table 6 and Table 1.
</bodyText>
<sectionHeader confidence="0.998483" genericHeader="references">
References
</sectionHeader>
<reference confidence="0.998240285714286">
Manex Agirrezabal, Bertol Arrieta, Aitzol Astigarraga,
and Mans Hulden. 2013. POS-Tag Based Po-
etry Generation with WordNet. In Proceedings of
the 14th European Workshop on Natural Language
Generation, pages 162–166, Sofia, Bulgaria.
Michael Auli, Michel Galley, Chris Quirk, and Geof-
frey Zweig. 2013. Joint Language and Translation
</reference>
<page confidence="0.993004">
678
</page>
<reference confidence="0.998747764150943">
Modeling with Recurrent Neural Networks. In Pro-
ceedings of the 2013 Conference on Empirical Meth-
ods in Natural Language Processing, pages 1044–
1054, Seattle, Washington, USA.
Chris Callison-Burch, Philipp Koehn, Christof Monz,
Matt Post, Radu Soricut, and Lucia Specia. 2012.
Findings of the 2012 Workshop on Statistical Ma-
chine Translation. In Proceedings of the 7th Work-
shop on Statistical Machine Translation, pages 10–
51, Montr´eal, Canada.
Simon Colton, Jacob Goodwin, and Tony Veale. 2012.
Full-FACE Poetry Generation. In Proceedings of the
International Conference on Computational Cre-
ativity, pages 95–102, Dublin, Ireland.
Christiane Fellbaum, editor. 1998. WordNet: An Elec-
tronic Database. MIT Press, Cambridge, MA.
Erica Greene, Tugba Bodrumlu, and Kevin Knight.
2010. Automatic Analysis of Rhythmic Poetry with
Applications to Generation and Translation. In Pro-
ceedings of the 2010 Conference on Empirical Meth-
ods in Natural Language Processing, pages 524–
533, Cambridge, MA.
Jing He, Ming Zhou, and Long Jiang. 2012. Gener-
ating Chinese Classical Poems with Statistical Ma-
chine Translation Models. In Proceedings of the
26th AAAI Conference on Artificial Intelligence,
pages 1650–1656, Toronto, Canada.
Kenneth Heafield. 2011. KenLM: Faster and Smaller
Language Model Queries. In Proceedings of the
EMNLP 2011 Sixth Workshop on Statistical Ma-
chine Translation, pages 187–197, Edinburgh, Scot-
land, United Kingdom, July.
Long Jiang and Ming Zhou. 2008. Generating Chinese
Couplets using a Statistical MT Approach. In Pro-
ceedings of the 22nd International Conference on
Computational Linguistics, pages 377–384, Manch-
ester, UK, August.
Nal Kalchbrenner and Phil Blunsom. 2013. Recurrent
Continuous Translation Models. In Proceedings of
the 2013 Conference on Empirical Methods in Natu-
ral Language Processing, pages 1700–1709, Seattle,
Washington.
Philipp Koehn, Franz Josef Och, and Daniel Marcu.
2003. Statistical Phrase-based Translation. In
Proceedings of the 2003 Conference of the North
American Chapter of the Association for Computa-
tional Linguistics on Human Language Technology-
Volume 1, pages 48–54, Edmonton, Canada.
Wenwei Liu. 1735. ShiXueHanYing.
Ruli Manurung, Graeme Ritchie, and Henry Thomp-
son. 2012. Using Genetic Algorithms to Create
Meaningful Poetic Text. Journal of Experimental
Theoretical Artificial Intelligence, 24(1):43–64.
Ruli Manurung. 2003. An Evolutionary Algorithm Ap-
proach to Poetry Generation. Ph.D. thesis, Univer-
sity of Edinburgh.
Tomas Mikolov and Geoffrey Zweig. 2012. Con-
text Dependent Recurrent Neural Network Lan-
guage Model. In Proceedings of 2012 IEEE Work-
shop on Spoken Language Technology, pages 234–
239, Miami, Florida.
Tomas Mikolov, Martin Karafi´at, Lukas Burget, Jan
Cernock`y, and Sanjeev Khudanpur. 2010. Recur-
rent Neural Network based Language Model. In
Proceedings of INTERSPEECH, pages 1045–1048,
Makuhari, Japan.
Tomas Mikolov, Anoop Deoras, Daniel Povey, Lukas
Burget, and Jan Cernocky. 2011a. Strategies
for Training Large Scale Neural Network Language
Models. In Proceedings of ASRU 2011, pages 196–
201, Hilton Waikoloa Village, Big Island, Hawaii,
US.
Tomas Mikolov, Stefan Kombrink, Lukas Burget,
JH Cernocky, and Sanjeev Khudanpur. 2011b. Ex-
tensions of Recurrent Neural Network Language
Model. In Proceedings of the 2011 IEEE Interna-
tional Conference on Acoustics, Speech and Signal
Processing, pages 5528–5531, Prague, Czech Re-
public.
Tomas Mikolov, Ilya Sutskever, Kai Chen, Greg S Cor-
rado, and Jeff Dean. 2013. Distributed Representa-
tions of Words and Phrases and their Composition-
ality. In Advances in Neural Information Process-
ing Systems, pages 3111–3119, Lake Tahoe, Nevada,
United States.
Jeff Mitchell and Mirella Lapata. 2010. Composition
in Distributional Models of Semantics. Cognitive
Science, 34(8):1388–1439.
Yael Netzer, David Gabay, Yoav Goldberg, and
Michael Elhadad. 2009. Gaiku: Generating Haiku
with Word Associations Norms. In Proceedings of
the Workshop on Computational Approaches to Lin-
guistic Creativity, pages 32–39, Boulder, Colorado.
Franz Josef Och. 2003. Minimum Error Rate Train-
ing in Statistical Machine Translation. In Proceed-
ings of the 41st Annual Meeting on Association
for Computational Linguistics, pages 160–167, Sap-
poro, Japan.
Hugo Gonc¸alo Oliveira. 2012. PoeTryMe: a Versa-
tile Platform for Poetry Generation. Computational
Creativity, Concept Invention, and General Intelli-
gence, 1:21.
David Rumelhart, Geoffrey Hinton, and Ronald
Williams. 1988. Learning Representations by Back-
propagating Errors. MIT Press, Cambridge, MA,
USA.
</reference>
<page confidence="0.98905">
679
</page>
<reference confidence="0.999657512820513">
Richard Socher, Brody Huval, Christopher D. Man-
ning, and Andrew Y. Ng. 2012. Semantic Compo-
sitionality through Recursive Matrix-Vector Spaces.
In Proceedings of the 2012 Joint Conference on
Empirical Methods in Natural Language Process-
ing and Computational Natural Language Learning,
pages 1201–1211, Jeju Island, Korea.
Naoko Tosa, Hideto Obara, and Michihiko Minoh.
2008. Hitch Haiku: An Interactive Supporting Sys-
tem for Composing Haiku Poem How I Learned to
Love the Bomb: Defcon and the Ethics of Com-
puter Games. In Proceedings of the 7th Inter-
national Conference on Entertainment Computing,
pages 209–216, Pittsburgh, PA.
Li Wang. 2002. A Summary of Rhyming Constraints
of Chinese Poems (Shi Ci Ge Lv Gai Yao). Beijing
Press, 2002.
Xiaofeng Wu, Naoko Tosa, and Ryohei Nakatsu. 2009.
New Hitch Haiku: An Interactive Renku Poem
Composition Supporting Tool Applied for Sightsee-
ing Navigation System. In Proceedings of the 8th
International Conference on Entertainment Com-
puting, pages 191–196, Paris, France.
Rui Yan, Han Jiang, Mirella Lapata, Shou-De Lin,
Xueqiang Lv, and Xiaoming Li. 2013. I, Poet:
Automatic Chinese Poetry Composition Through a
Generative Summarization Framework Under Con-
strained Optimization. In Proceedings of the 23rd
International Joint Conference on Artificial Intelli-
gence, pages 2197–2203, Beijing, China.
Cheng-Le Zhou, Wei You, and Xiaojun Ding. 2010.
Genetic Algorithm and its Implementation of Au-
tomatic Generation of Chinese SongCi. Journal of
Software, pages 427–437.
Geoffrey Zweig and Konstantin Makarychev. 2013.
Speed Regularization and Optimality in Word Class-
ing. In Proceedings of the 2014 IEEE International
Conference on Acoustics, Speech, and Signal Pro-
cessing, pages 8237–8241, Florence, Italy.
</reference>
<page confidence="0.997676">
680
</page>
</variant>
</algorithm>
<algorithm name="ParsHed" version="110505">
<variant no="0" confidence="0.967343">
<title confidence="0.999415">Chinese Poetry Generation with Recurrent Neural Networks</title>
<author confidence="0.99042">Zhang</author>
<affiliation confidence="0.999087">Institute for Language, Cognition and School of Informatics, University of</affiliation>
<address confidence="0.986052">10 Crichton Street, Edinburgh EH8</address>
<email confidence="0.998242">x.zhang@ed.ac.uk,mlap@inf.ed.ac.uk</email>
<abstract confidence="0.9996567">We propose a model for Chinese poem generation based on recurrent neural networks which we argue is ideally suited to capturing poetic content and form. Our content selection (“what to say”) and surface realization (“how to say”) by learning representations of individual characters, and their combinations into one or more lines as well as how these mutually reinforce and constrain each other. Poem lines are generated incrementally by taking into account the entire history of what has been generated so far rather than the limited horizon imposed by the previous line or lexical Experimental results show that our model outperforms competitive Chinese poetry generation systems using both automatic and manual evaluation methods.</abstract>
</variant>
</algorithm>
<algorithm name="ParsCit" version="110505">
<citationList>
<citation valid="true">
<authors>
<author>Manex Agirrezabal</author>
<author>Bertol Arrieta</author>
<author>Aitzol Astigarraga</author>
<author>Mans Hulden</author>
</authors>
<title>POS-Tag Based Poetry Generation with WordNet.</title>
<date>2013</date>
<booktitle>In Proceedings of the 14th European Workshop on Natural Language Generation,</booktitle>
<pages>162--166</pages>
<location>Sofia, Bulgaria.</location>
<contexts>
<context position="6255" citStr="Agirrezabal et al. (2013)" startWordPosition="1003" endWordPosition="1006">k Automated poetry generation has been a popular research topic over the past decades (see Colton et al. (2012) and the references therein). Most approaches employ templates to construct poems according to a set of constraints (e.g., rhyme, meter, stress, word frequency) in combination with corpus-based and lexicographic resources. For example, the Haiku poem generator presented in Wu et al. (2009) and Tosa et al. (2008) produces poems by expanding user queries with rules extracted from a corpus and additional lexical resources. Netzer et al. (2009) generate Haiku with Word Association Norms, Agirrezabal et al. (2013) compose Basque poems using patterns based on parts of speech and WordNet (Fellbaum, 1998), and Oliveira (2012) presents a generation algorithm for Portuguese which leverages semantic and grammar templates. A second line of research uses genetic algorithms for poem generation (Manurung, 2003; Manurung et al., 2012; Zhou et al., 2010). Manurung et al. (2012) argue that at a basic level all (machine-generated) poems must satisfy the constraints of grammaticality (i.e., a poem must syntactically well-formed), meaningfulness (i.e., a poem must convey a message that is meaningful under some interpr</context>
</contexts>
<marker>Agirrezabal, Arrieta, Astigarraga, Hulden, 2013</marker>
<rawString>Manex Agirrezabal, Bertol Arrieta, Aitzol Astigarraga, and Mans Hulden. 2013. POS-Tag Based Poetry Generation with WordNet. In Proceedings of the 14th European Workshop on Natural Language Generation, pages 162–166, Sofia, Bulgaria.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Michael Auli</author>
<author>Michel Galley</author>
<author>Chris Quirk</author>
<author>Geoffrey Zweig</author>
</authors>
<title>Joint Language and Translation Modeling with Recurrent Neural Networks.</title>
<date>2013</date>
<booktitle>In Proceedings of the 2013 Conference on Empirical Methods in Natural Language Processing,</booktitle>
<pages>1044--1054</pages>
<location>Seattle, Washington, USA.</location>
<contexts>
<context position="9614" citStr="Auli et al., 2013" startWordPosition="1517" endWordPosition="1520"> of individual characters and their combinations. Secondly, generation proceeds by taking into account multi-sentential context rather than the immediately preceding sentence. Our work joins others in using continuous representations to express the meaning of words and phrases (Socher et al., 2012; Mikolov et al., 2013) and how these may be combined in a language modeling context (Mikolov and Zweig, 2012). More recently, continuous translation models based on recurrent neural networks have been proposed as a means to map a sentence from the source language to sentences in the target language (Auli et al., 2013; Kalchbrenner and Blunsom, 2013). These models are evaluated on the task of rescoring n-best lists of translations. We use neural networks more directly to perform the actual poem generation task. 3 The Poem Generator As common in previous work (Yan et al., 2013; He et al., 2012) we assume that our generator operates in an interactive context. Specifically, the user supplies keywords (e.g., spring, lute, drunk) highlighting the main concepts around which the poem will revolve. As illustrated in Figure 1, our generator expands these keywords into a set of related phrases. We assume the keyword</context>
<context position="17700" citStr="Auli et al., 2013" startWordPosition="2915" endWordPosition="2918">eration Model (RGM) As shown in Figure 2, the RGM estimates the probability distribution of the next character (over the entire vocabulary) by taking into account the context vector provided by the RCM and the 1-of-N encoding of the previous character. The RGM is essentially a recurrent neural network language model (Mikolov et al., 2010) with an auxiliary input layer, i.e., the context vector from the RCM. Similar strategies for encoding additional information have been adopted in related language modeling and machine translation work (Mikolov and Zweig, 2012; Kalchbrenner and Blunsom, 2013; Auli et al., 2013). Let Si+1 = w1,w2,...,wm denote the line to be generated. The RGM must estimate P(wj+1|w1:j,S1:i), however, since the first i lines have been encoded in the context vector uji , we compute P(wj+1|w1:j,uji ) instead. Therefore, the probability P(Si+1|S1:i) becomes: P(wj+1|w1:j,uji ) (6) Let |V |denote the size of the character vocabulary. The RGM is specified by a number of matrices. Matrix H ∈ Rq×q (where q represents the hidden unit size) transforms the context vector to a hidden representation; matrix X ∈ Rq×|V |transforms a character to a hidden representation, matrix R ∈ Rq×q implements t</context>
</contexts>
<marker>Auli, Galley, Quirk, Zweig, 2013</marker>
<rawString>Michael Auli, Michel Galley, Chris Quirk, and Geoffrey Zweig. 2013. Joint Language and Translation Modeling with Recurrent Neural Networks. In Proceedings of the 2013 Conference on Empirical Methods in Natural Language Processing, pages 1044– 1054, Seattle, Washington, USA.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Chris Callison-Burch</author>
<author>Philipp Koehn</author>
<author>Christof Monz</author>
<author>Matt Post</author>
<author>Radu Soricut</author>
<author>Lucia Specia</author>
</authors>
<date>2012</date>
<booktitle>Findings of the 2012 Workshop on Statistical Machine Translation. In Proceedings of the 7th Workshop on Statistical Machine Translation,</booktitle>
<pages>10--51</pages>
<location>Montr´eal, Canada.</location>
<contexts>
<context position="25962" citStr="Callison-Burch et al., 2012" startWordPosition="4296" endWordPosition="4299">0 experts3 on Chinese poetry to assess the output of our generator (and comparison systems). These experts were asked to rate the poems using a 1–5 scale on four dimensions: fluency (is the poem grammatical and syntactically well-formed?), coherence (is the poem thematically and logically structured?), meaningfulness (does the poem convey a meaningful message to the reader?) and poeticness (does the text display the features of a poem?). We also asked our participants to evaluate system outputs by ranking the generated poems relative to each other as a way of determining overall poem quality (Callison-Burch et al., 2012). Participants rated the output of our model and three comparison systems. These included He et al.’s (2012) SMT-based model (SMT), Yan et al.’s (2013) summarization-based system (SUM), and a random baseline which creates poems by randomly selecting phrases from the Shixuehanying taxonomy given some keywords as input. We also included human written poems whose content matched the input keywords. All systems were provided with the same keywords (i.e., the same cluster names in the ShiXueHanYing taxonomy). In order to compare all models on equal footing, we randomly sampled 30 sets of keywords (</context>
<context position="30295" citStr="Callison-Burch et al., 2012" startWordPosition="5014" endWordPosition="5017">as a whole and there is no obvious way to generate next lines with their 4Our re-implementation of their system delivered very similar scores to He et al. (2012). For example, we obtained an average BLEU-1 of 0.167 for 5-char quatrains and 0.428 for 7-char quatrains compared to their reported scores of 0.141 and 0.380, respectively. algorithm. The BLEU scores in Table 4 indicate that, given the same context lines, the RNNPG is better than SMT at generating what to say next. BLEU scores should be, however, viewed with some degree of caution. Aside from being an approximation of human judgment (Callison-Burch et al., 2012), BLEU might be unnecessarily conservative for poem composition which by its very nature is a creative endeavor. The results of our human evaluation study are shown in Table 5. Each column reports mean ratings for a different dimension (e.g., fluency, coherence). Ratings for 5-char and 7-char quatrains are shown separately. The last column reports rank scores for each system (Callison-Burch et al., 2012). In a ranked list of N items (N = 5 here), the score of the ith ranked item is (N−i) (N−1). The numerator indicates how many times a systems won in pairwise comparisons, while the denominator </context>
</contexts>
<marker>Callison-Burch, Koehn, Monz, Post, Soricut, Specia, 2012</marker>
<rawString>Chris Callison-Burch, Philipp Koehn, Christof Monz, Matt Post, Radu Soricut, and Lucia Specia. 2012. Findings of the 2012 Workshop on Statistical Machine Translation. In Proceedings of the 7th Workshop on Statistical Machine Translation, pages 10– 51, Montr´eal, Canada.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Simon Colton</author>
<author>Jacob Goodwin</author>
<author>Tony Veale</author>
</authors>
<title>Full-FACE Poetry Generation.</title>
<date>2012</date>
<booktitle>In Proceedings of the International Conference on Computational Creativity,</booktitle>
<pages>95--102</pages>
<location>Dublin, Ireland.</location>
<contexts>
<context position="5741" citStr="Colton et al. (2012)" startWordPosition="921" endWordPosition="924">ov et al., 2011a) which generates the current line. In contrast to previous approaches (Greene et al., 2010; Jiang and Zhou, 2008), our generator makes no Markov assumptions about the dependencies of the words within a line and across lines. We evaluate our approach on the task of quatrain generation (see Table 1 for a human-written example). Experimental results show that our model outperforms competitive Chinese poetry generation systems using both automatic and manual evaluation methods. 2 Related Work Automated poetry generation has been a popular research topic over the past decades (see Colton et al. (2012) and the references therein). Most approaches employ templates to construct poems according to a set of constraints (e.g., rhyme, meter, stress, word frequency) in combination with corpus-based and lexicographic resources. For example, the Haiku poem generator presented in Wu et al. (2009) and Tosa et al. (2008) produces poems by expanding user queries with rules extracted from a corpus and additional lexical resources. Netzer et al. (2009) generate Haiku with Word Association Norms, Agirrezabal et al. (2013) compose Basque poems using patterns based on parts of speech and WordNet (Fellbaum, 1</context>
</contexts>
<marker>Colton, Goodwin, Veale, 2012</marker>
<rawString>Simon Colton, Jacob Goodwin, and Tony Veale. 2012. Full-FACE Poetry Generation. In Proceedings of the International Conference on Computational Creativity, pages 95–102, Dublin, Ireland.</rawString>
</citation>
<citation valid="true">
<title>WordNet: An Electronic Database.</title>
<date>1998</date>
<editor>Christiane Fellbaum, editor.</editor>
<publisher>MIT Press,</publisher>
<location>Cambridge, MA.</location>
<marker>1998</marker>
<rawString>Christiane Fellbaum, editor. 1998. WordNet: An Electronic Database. MIT Press, Cambridge, MA.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Erica Greene</author>
<author>Tugba Bodrumlu</author>
<author>Kevin Knight</author>
</authors>
<title>Automatic Analysis of Rhythmic Poetry with Applications to Generation and Translation.</title>
<date>2010</date>
<booktitle>In Proceedings of the 2010 Conference on Empirical Methods in Natural Language Processing,</booktitle>
<pages>524--533</pages>
<location>Cambridge, MA.</location>
<contexts>
<context position="5228" citStr="Greene et al., 2010" startWordPosition="840" endWordPosition="843">entations of individual characters, and their combinations into one or more lines as well as how these mutually reinforce and constrain each other. Our model generates lines in a poem probabilistically: it estimates the probability of the current line given the probability of all previously generated lines. We use a recurrent neural network to learn the representations of the lines generated so far which in turn serve as input to a recurrent language model (Mikolov et al., 2010; Mikolov et al., 2011b; Mikolov et al., 2011a) which generates the current line. In contrast to previous approaches (Greene et al., 2010; Jiang and Zhou, 2008), our generator makes no Markov assumptions about the dependencies of the words within a line and across lines. We evaluate our approach on the task of quatrain generation (see Table 1 for a human-written example). Experimental results show that our model outperforms competitive Chinese poetry generation systems using both automatic and manual evaluation methods. 2 Related Work Automated poetry generation has been a popular research topic over the past decades (see Colton et al. (2012) and the references therein). Most approaches employ templates to construct poems accor</context>
<context position="7282" citStr="Greene et al. (2010)" startWordPosition="1157" endWordPosition="1160">ted) poems must satisfy the constraints of grammaticality (i.e., a poem must syntactically well-formed), meaningfulness (i.e., a poem must convey a message that is meaningful under some interpretation) and poeticness (i.e., a poem must exhibit features that distinguishes it from non-poetic text, e.g., metre). Their model generates several candidate poems and then uses stochastic search to find those which are grammatical, meaningful, and poetic. A third line of research draws inspiration from statistical machine translation (SMT) and related text-generation applications such as summarization. Greene et al. (2010) infer meters (stressed/unstressed syllable sequences) from a corpus of poetic texts which they subsequently use for generation together with a cascade of weighted finite-state transducers interpolated with IBM Model 1. Jiang and Zhou (2008) generate Chinese couplets (two line poems) using a phrasebased SMT approach which translates the first line to the second line. He et al. (2012) extend this algorithm to generate four-line quatrains by sequentially translating the current line from the previous one. Yan et al. (2013) generate Chinese quatrains based on a query-focused summarization framewo</context>
</contexts>
<marker>Greene, Bodrumlu, Knight, 2010</marker>
<rawString>Erica Greene, Tugba Bodrumlu, and Kevin Knight. 2010. Automatic Analysis of Rhythmic Poetry with Applications to Generation and Translation. In Proceedings of the 2010 Conference on Empirical Methods in Natural Language Processing, pages 524– 533, Cambridge, MA.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Jing He</author>
<author>Ming Zhou</author>
<author>Long Jiang</author>
</authors>
<title>Generating Chinese Classical Poems with Statistical Machine Translation Models.</title>
<date>2012</date>
<booktitle>In Proceedings of the 26th AAAI Conference on Artificial Intelligence,</booktitle>
<pages>1650--1656</pages>
<location>Toronto, Canada.</location>
<contexts>
<context position="7668" citStr="He et al. (2012)" startWordPosition="1216" endWordPosition="1219">o find those which are grammatical, meaningful, and poetic. A third line of research draws inspiration from statistical machine translation (SMT) and related text-generation applications such as summarization. Greene et al. (2010) infer meters (stressed/unstressed syllable sequences) from a corpus of poetic texts which they subsequently use for generation together with a cascade of weighted finite-state transducers interpolated with IBM Model 1. Jiang and Zhou (2008) generate Chinese couplets (two line poems) using a phrasebased SMT approach which translates the first line to the second line. He et al. (2012) extend this algorithm to generate four-line quatrains by sequentially translating the current line from the previous one. Yan et al. (2013) generate Chinese quatrains based on a query-focused summarization framework. Their system takes a few keywords as input and retrieves the most relevant poems from a corpus collection. The retrieved poems are segmented into their constituent terms which are then grouped into clusters. Poems are generated by iteratively selecting terms from clusters subject to phonological, structural, and coherence constraints. Our approach departs from previous work in tw</context>
<context position="9895" citStr="He et al., 2012" startWordPosition="1566" endWordPosition="1569">her et al., 2012; Mikolov et al., 2013) and how these may be combined in a language modeling context (Mikolov and Zweig, 2012). More recently, continuous translation models based on recurrent neural networks have been proposed as a means to map a sentence from the source language to sentences in the target language (Auli et al., 2013; Kalchbrenner and Blunsom, 2013). These models are evaluated on the task of rescoring n-best lists of translations. We use neural networks more directly to perform the actual poem generation task. 3 The Poem Generator As common in previous work (Yan et al., 2013; He et al., 2012) we assume that our generator operates in an interactive context. Specifically, the user supplies keywords (e.g., spring, lute, drunk) highlighting the main concepts around which the poem will revolve. As illustrated in Figure 1, our generator expands these keywords into a set of related phrases. We assume the keywords are restricted to those attested in the ShiXueHanYing poetic phrase taxonomy (He et al., 2012; Yan et al., 2013). The latter contains 1,016 manual clusters of phrases (Liu, 1735); each cluster is labeled with a keyword id describing general poem-worthy topics. The generator crea</context>
<context position="24626" citStr="He et al. (2012)" startWordPosition="4064" endWordPosition="4067">gfulness, and poeticness. As a sanity check, we first measured the perplexity of our model with respect to the goldstandard. Intuitively, a better model should assign larger probability (and therefore lower perplexity) to goldstandard poems. BLEU-based Evaluation We also used BLEU to evaluate our model’s ability to generate the second, third and fourth line given previous goldstandard lines. A problematic aspect of this evaluation is the need for human-authored references (for a partially generated poem) which we do not have. We obtain references automatically following the method proposed in He et al. (2012). The main idea is that if two lines share a similar topic, the lines following them can be each other’s references. Let A and B denote two adjacent lines in a poem, with B following A. Similarly, let line B0 follow line A0 in another poem. If lines A and A0 share some keywords in the same cluster in the Shixuehanying taxonomy, then B and B0 can be used as references for both A and A0. We use this algorithm on the Tang Poems section of our corpus to build references for poems in the QVALID and QTEST data sets. Poems in QVALID (with autogenerated references) were used for MERT training and Poem</context>
<context position="29077" citStr="He et al., 2012" startWordPosition="4811" endWordPosition="4814">tes the probability of a poem line given at least one previous line. Therefore, the probability of a quatrain assigned by the RNNPG is the probability of the last three lines. For a fair comparison, RNNLM and KN5 only leverage the last three lines of each poem during training, validation and testing. The results in Table 3 indicate that the generation ability of the RNNPG is better than KN5 and RNNLM. Note that this perplexitystyle evaluation is not possible for models which cannot produce probabilities for gold standard poems. For this reason, other related poem generators (Yan et al., 2013; He et al., 2012) are not included in the table. The results of our evaluation using BLEU-2 are summarized in Table 4. Here, we compare our system against the SMT-based poem generation model of He et al. (2012).4 Their system is a linear combination of two translation models (one with five features and another one with six). Our model uses three of their features, namely the inverted phrase translation model feature, the lexical weight feature, and a Kneser-Ney trigram feature. Unfortunately, it is not possible to evaluate Yan et al.’s (2013) summarization-based system with BLEU, as it creates poems as a whole</context>
</contexts>
<marker>He, Zhou, Jiang, 2012</marker>
<rawString>Jing He, Ming Zhou, and Long Jiang. 2012. Generating Chinese Classical Poems with Statistical Machine Translation Models. In Proceedings of the 26th AAAI Conference on Artificial Intelligence, pages 1650–1656, Toronto, Canada.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Kenneth Heafield</author>
</authors>
<title>KenLM: Faster and Smaller Language Model Queries.</title>
<date>2011</date>
<booktitle>In Proceedings of the EMNLP 2011 Sixth Workshop on Statistical Machine Translation,</booktitle>
<pages>187--197</pages>
<location>Edinburgh, Scotland, United Kingdom,</location>
<contexts>
<context position="21861" citStr="Heafield, 2011" startWordPosition="3627" endWordPosition="3628">ore this observation. This way, there is no explicitly defined context, and history is captured implicitly by the recurrent nature of the model. This can be problematic for our texts which must obey certain stylistic conventions and sound poetic. In default of a better way of incorporating poeticness into our model, we further interpolate it with a language model feature (i.e., a Kneser-Ney trigram model). Throughout our experiments, we use the RNNLM toolkit to train the character-based recurrent neural network language model (Mikolov et al., 2010). Kneser-Ney n-grams were trained with KenLM (Heafield, 2011). 3.5 Decoding Our decoder is a stack decoder similar to Koehn et al. (2003). In addition, it implements the tonal pattern and rhyming constraints necessary for generating well-formed Chinese quatrains. Once the first line in a poem is generated, its tonal pattern is determined. During decoding, phrases violating this pattern are ignored. As discussed in Section 1, the final characters of the second and the fourth lines must rhyme. We thus remove during decoding fourth lines whose final characters do not rhyme with the second line. Finally, we use MERT training (Och, 2003) to learn feature wei</context>
</contexts>
<marker>Heafield, 2011</marker>
<rawString>Kenneth Heafield. 2011. KenLM: Faster and Smaller Language Model Queries. In Proceedings of the EMNLP 2011 Sixth Workshop on Statistical Machine Translation, pages 187–197, Edinburgh, Scotland, United Kingdom, July.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Long Jiang</author>
<author>Ming Zhou</author>
</authors>
<title>Generating Chinese Couplets using a Statistical MT Approach.</title>
<date>2008</date>
<booktitle>In Proceedings of the 22nd International Conference on Computational Linguistics,</booktitle>
<pages>377--384</pages>
<location>Manchester, UK,</location>
<contexts>
<context position="5251" citStr="Jiang and Zhou, 2008" startWordPosition="844" endWordPosition="847">al characters, and their combinations into one or more lines as well as how these mutually reinforce and constrain each other. Our model generates lines in a poem probabilistically: it estimates the probability of the current line given the probability of all previously generated lines. We use a recurrent neural network to learn the representations of the lines generated so far which in turn serve as input to a recurrent language model (Mikolov et al., 2010; Mikolov et al., 2011b; Mikolov et al., 2011a) which generates the current line. In contrast to previous approaches (Greene et al., 2010; Jiang and Zhou, 2008), our generator makes no Markov assumptions about the dependencies of the words within a line and across lines. We evaluate our approach on the task of quatrain generation (see Table 1 for a human-written example). Experimental results show that our model outperforms competitive Chinese poetry generation systems using both automatic and manual evaluation methods. 2 Related Work Automated poetry generation has been a popular research topic over the past decades (see Colton et al. (2012) and the references therein). Most approaches employ templates to construct poems according to a set of constr</context>
<context position="7523" citStr="Jiang and Zhou (2008)" startWordPosition="1191" endWordPosition="1194">bit features that distinguishes it from non-poetic text, e.g., metre). Their model generates several candidate poems and then uses stochastic search to find those which are grammatical, meaningful, and poetic. A third line of research draws inspiration from statistical machine translation (SMT) and related text-generation applications such as summarization. Greene et al. (2010) infer meters (stressed/unstressed syllable sequences) from a corpus of poetic texts which they subsequently use for generation together with a cascade of weighted finite-state transducers interpolated with IBM Model 1. Jiang and Zhou (2008) generate Chinese couplets (two line poems) using a phrasebased SMT approach which translates the first line to the second line. He et al. (2012) extend this algorithm to generate four-line quatrains by sequentially translating the current line from the previous one. Yan et al. (2013) generate Chinese quatrains based on a query-focused summarization framework. Their system takes a few keywords as input and retrieves the most relevant poems from a corpus collection. The retrieved poems are segmented into their constituent terms which are then grouped into clusters. Poems are generated by iterat</context>
<context position="20869" citStr="Jiang and Zhou, 2008" startWordPosition="3473" endWordPosition="3476">lity of its class and then multiply it by the probability of the character conditioned on the class. In our experiments we used 82 (square root of |V|) classes which we obtained by applying hierarchical clustering on character embeddings. This strategy outperformed better known frequency-based classing methods (Zweig and Makarychev, 2013) on our task. Our poem generator models content selection and lexical choice and their interaction, but does not have a strong notion of local coherence, as manifested in poetically felicitous line-to-line transitions. In contrast, machine translation models (Jiang and Zhou, 2008) have been particularly successful at generating adjacent lines (couplets). To enhance coherence, we thus interpolate our model with two machine translation features (i.e., inverted phrase translation model feature and inverted lexical weight feature). Also note, that in our model surface generation depends on the last observed character and the state of the hidden layer before this observation. This way, there is no explicitly defined context, and history is captured implicitly by the recurrent nature of the model. This can be problematic for our texts which must obey certain stylistic conven</context>
</contexts>
<marker>Jiang, Zhou, 2008</marker>
<rawString>Long Jiang and Ming Zhou. 2008. Generating Chinese Couplets using a Statistical MT Approach. In Proceedings of the 22nd International Conference on Computational Linguistics, pages 377–384, Manchester, UK, August.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Nal Kalchbrenner</author>
<author>Phil Blunsom</author>
</authors>
<title>Recurrent Continuous Translation Models.</title>
<date>2013</date>
<booktitle>In Proceedings of the 2013 Conference on Empirical Methods in Natural Language Processing,</booktitle>
<pages>1700--1709</pages>
<location>Seattle, Washington.</location>
<contexts>
<context position="9647" citStr="Kalchbrenner and Blunsom, 2013" startWordPosition="1521" endWordPosition="1524">acters and their combinations. Secondly, generation proceeds by taking into account multi-sentential context rather than the immediately preceding sentence. Our work joins others in using continuous representations to express the meaning of words and phrases (Socher et al., 2012; Mikolov et al., 2013) and how these may be combined in a language modeling context (Mikolov and Zweig, 2012). More recently, continuous translation models based on recurrent neural networks have been proposed as a means to map a sentence from the source language to sentences in the target language (Auli et al., 2013; Kalchbrenner and Blunsom, 2013). These models are evaluated on the task of rescoring n-best lists of translations. We use neural networks more directly to perform the actual poem generation task. 3 The Poem Generator As common in previous work (Yan et al., 2013; He et al., 2012) we assume that our generator operates in an interactive context. Specifically, the user supplies keywords (e.g., spring, lute, drunk) highlighting the main concepts around which the poem will revolve. As illustrated in Figure 1, our generator expands these keywords into a set of related phrases. We assume the keywords are restricted to those atteste</context>
<context position="13520" citStr="Kalchbrenner and Blunsom (2013)" startWordPosition="2170" endWordPosition="2173">M(Si) (2a) uij = RCM(v1:i, j) (2b) P(wj+1|w1: j,S1:i) = RGM(w1: j+1,u1: j i ) (2c) We obtain the probability of the (i + 1)th sentence P(Si+1|S1:i), by running the RGM in (2c) above m −1 times (see also Equation (1)). In the following, we describe how the different components of our model are obtained. 3.1 Convolutional Sentence Model (CSM) The CSM converts a poem line into a vector. In principle, any model that produces vector-based representations of phrases or sentences could be used (Mitchell and Lapata, 2010; Socher et al., 2012). We opted for the convolutional sentence model proposed in Kalchbrenner and Blunsom (2013) as it is n-gram based and does not make use of any parsing, POS-tagging or segmentation tools which are not available for Chinese poems. Their model computes a continuous representation for a sentence by sequentially merging neighboring vectors (see Figure 3). Let V denote the character vocabulary in our corpus; L ∈ Rq×|V |denotes a character embedding matrix whose columns correspond to character vectors (q represents the hidden unit size). Such vectors can be initialized randomly or obtained via a training procedure (Mikolov et al., 2013). Let w denote a character with index k; e(w) ∈ R|V|×1</context>
<context position="17680" citStr="Kalchbrenner and Blunsom, 2013" startWordPosition="2911" endWordPosition="2914">ins tractable. 3.3 Recurrent Generation Model (RGM) As shown in Figure 2, the RGM estimates the probability distribution of the next character (over the entire vocabulary) by taking into account the context vector provided by the RCM and the 1-of-N encoding of the previous character. The RGM is essentially a recurrent neural network language model (Mikolov et al., 2010) with an auxiliary input layer, i.e., the context vector from the RCM. Similar strategies for encoding additional information have been adopted in related language modeling and machine translation work (Mikolov and Zweig, 2012; Kalchbrenner and Blunsom, 2013; Auli et al., 2013). Let Si+1 = w1,w2,...,wm denote the line to be generated. The RGM must estimate P(wj+1|w1:j,S1:i), however, since the first i lines have been encoded in the context vector uji , we compute P(wj+1|w1:j,uji ) instead. Therefore, the probability P(Si+1|S1:i) becomes: P(wj+1|w1:j,uji ) (6) Let |V |denote the size of the character vocabulary. The RGM is specified by a number of matrices. Matrix H ∈ Rq×q (where q represents the hidden unit size) transforms the context vector to a hidden representation; matrix X ∈ Rq×|V |transforms a character to a hidden representation, matrix R</context>
</contexts>
<marker>Kalchbrenner, Blunsom, 2013</marker>
<rawString>Nal Kalchbrenner and Phil Blunsom. 2013. Recurrent Continuous Translation Models. In Proceedings of the 2013 Conference on Empirical Methods in Natural Language Processing, pages 1700–1709, Seattle, Washington.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Philipp Koehn</author>
<author>Franz Josef Och</author>
<author>Daniel Marcu</author>
</authors>
<title>Statistical Phrase-based Translation.</title>
<date>2003</date>
<booktitle>In Proceedings of the 2003 Conference of the North American Chapter of the Association for Computational Linguistics on Human Language TechnologyVolume 1,</booktitle>
<tech>Wenwei Liu. 1735. ShiXueHanYing.</tech>
<pages>48--54</pages>
<location>Edmonton,</location>
<contexts>
<context position="21937" citStr="Koehn et al. (2003)" startWordPosition="3639" endWordPosition="3642">and history is captured implicitly by the recurrent nature of the model. This can be problematic for our texts which must obey certain stylistic conventions and sound poetic. In default of a better way of incorporating poeticness into our model, we further interpolate it with a language model feature (i.e., a Kneser-Ney trigram model). Throughout our experiments, we use the RNNLM toolkit to train the character-based recurrent neural network language model (Mikolov et al., 2010). Kneser-Ney n-grams were trained with KenLM (Heafield, 2011). 3.5 Decoding Our decoder is a stack decoder similar to Koehn et al. (2003). In addition, it implements the tonal pattern and rhyming constraints necessary for generating well-formed Chinese quatrains. Once the first line in a poem is generated, its tonal pattern is determined. During decoding, phrases violating this pattern are ignored. As discussed in Section 1, the final characters of the second and the fourth lines must rhyme. We thus remove during decoding fourth lines whose final characters do not rhyme with the second line. Finally, we use MERT training (Och, 2003) to learn feature weights for the decoder. 4 Experimental Design Data We created a corpus of clas</context>
</contexts>
<marker>Koehn, Och, Marcu, 2003</marker>
<rawString>Philipp Koehn, Franz Josef Och, and Daniel Marcu. 2003. Statistical Phrase-based Translation. In Proceedings of the 2003 Conference of the North American Chapter of the Association for Computational Linguistics on Human Language TechnologyVolume 1, pages 48–54, Edmonton, Canada. Wenwei Liu. 1735. ShiXueHanYing.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Ruli Manurung</author>
<author>Graeme Ritchie</author>
<author>Henry Thompson</author>
</authors>
<title>Using Genetic Algorithms to Create Meaningful Poetic Text.</title>
<date>2012</date>
<journal>Journal of Experimental Theoretical Artificial Intelligence,</journal>
<volume>24</volume>
<issue>1</issue>
<contexts>
<context position="6570" citStr="Manurung et al., 2012" startWordPosition="1051" endWordPosition="1054">hic resources. For example, the Haiku poem generator presented in Wu et al. (2009) and Tosa et al. (2008) produces poems by expanding user queries with rules extracted from a corpus and additional lexical resources. Netzer et al. (2009) generate Haiku with Word Association Norms, Agirrezabal et al. (2013) compose Basque poems using patterns based on parts of speech and WordNet (Fellbaum, 1998), and Oliveira (2012) presents a generation algorithm for Portuguese which leverages semantic and grammar templates. A second line of research uses genetic algorithms for poem generation (Manurung, 2003; Manurung et al., 2012; Zhou et al., 2010). Manurung et al. (2012) argue that at a basic level all (machine-generated) poems must satisfy the constraints of grammaticality (i.e., a poem must syntactically well-formed), meaningfulness (i.e., a poem must convey a message that is meaningful under some interpretation) and poeticness (i.e., a poem must exhibit features that distinguishes it from non-poetic text, e.g., metre). Their model generates several candidate poems and then uses stochastic search to find those which are grammatical, meaningful, and poetic. A third line of research draws inspiration from statistica</context>
</contexts>
<marker>Manurung, Ritchie, Thompson, 2012</marker>
<rawString>Ruli Manurung, Graeme Ritchie, and Henry Thompson. 2012. Using Genetic Algorithms to Create Meaningful Poetic Text. Journal of Experimental Theoretical Artificial Intelligence, 24(1):43–64.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Ruli Manurung</author>
</authors>
<title>An Evolutionary Algorithm Approach to Poetry Generation.</title>
<date>2003</date>
<tech>Ph.D. thesis,</tech>
<institution>University of Edinburgh.</institution>
<contexts>
<context position="6547" citStr="Manurung, 2003" startWordPosition="1049" endWordPosition="1050">d and lexicographic resources. For example, the Haiku poem generator presented in Wu et al. (2009) and Tosa et al. (2008) produces poems by expanding user queries with rules extracted from a corpus and additional lexical resources. Netzer et al. (2009) generate Haiku with Word Association Norms, Agirrezabal et al. (2013) compose Basque poems using patterns based on parts of speech and WordNet (Fellbaum, 1998), and Oliveira (2012) presents a generation algorithm for Portuguese which leverages semantic and grammar templates. A second line of research uses genetic algorithms for poem generation (Manurung, 2003; Manurung et al., 2012; Zhou et al., 2010). Manurung et al. (2012) argue that at a basic level all (machine-generated) poems must satisfy the constraints of grammaticality (i.e., a poem must syntactically well-formed), meaningfulness (i.e., a poem must convey a message that is meaningful under some interpretation) and poeticness (i.e., a poem must exhibit features that distinguishes it from non-poetic text, e.g., metre). Their model generates several candidate poems and then uses stochastic search to find those which are grammatical, meaningful, and poetic. A third line of research draws insp</context>
</contexts>
<marker>Manurung, 2003</marker>
<rawString>Ruli Manurung. 2003. An Evolutionary Algorithm Approach to Poetry Generation. Ph.D. thesis, University of Edinburgh.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Tomas Mikolov</author>
<author>Geoffrey Zweig</author>
</authors>
<title>Context Dependent Recurrent Neural Network Language Model.</title>
<date>2012</date>
<booktitle>In Proceedings of 2012 IEEE Workshop on Spoken Language Technology,</booktitle>
<pages>234--239</pages>
<location>Miami, Florida.</location>
<contexts>
<context position="9405" citStr="Mikolov and Zweig, 2012" startWordPosition="1482" endWordPosition="1485">nt the representations of all previously generated lines. using recurrent neural networks. Structural, semantic, and coherence constraints are captured naturally in our framework, through learning the representations of individual characters and their combinations. Secondly, generation proceeds by taking into account multi-sentential context rather than the immediately preceding sentence. Our work joins others in using continuous representations to express the meaning of words and phrases (Socher et al., 2012; Mikolov et al., 2013) and how these may be combined in a language modeling context (Mikolov and Zweig, 2012). More recently, continuous translation models based on recurrent neural networks have been proposed as a means to map a sentence from the source language to sentences in the target language (Auli et al., 2013; Kalchbrenner and Blunsom, 2013). These models are evaluated on the task of rescoring n-best lists of translations. We use neural networks more directly to perform the actual poem generation task. 3 The Poem Generator As common in previous work (Yan et al., 2013; He et al., 2012) we assume that our generator operates in an interactive context. Specifically, the user supplies keywords (e.</context>
<context position="17648" citStr="Mikolov and Zweig, 2012" startWordPosition="2907" endWordPosition="2910"> of parameters still remains tractable. 3.3 Recurrent Generation Model (RGM) As shown in Figure 2, the RGM estimates the probability distribution of the next character (over the entire vocabulary) by taking into account the context vector provided by the RCM and the 1-of-N encoding of the previous character. The RGM is essentially a recurrent neural network language model (Mikolov et al., 2010) with an auxiliary input layer, i.e., the context vector from the RCM. Similar strategies for encoding additional information have been adopted in related language modeling and machine translation work (Mikolov and Zweig, 2012; Kalchbrenner and Blunsom, 2013; Auli et al., 2013). Let Si+1 = w1,w2,...,wm denote the line to be generated. The RGM must estimate P(wj+1|w1:j,S1:i), however, since the first i lines have been encoded in the context vector uji , we compute P(wj+1|w1:j,uji ) instead. Therefore, the probability P(Si+1|S1:i) becomes: P(wj+1|w1:j,uji ) (6) Let |V |denote the size of the character vocabulary. The RGM is specified by a number of matrices. Matrix H ∈ Rq×q (where q represents the hidden unit size) transforms the context vector to a hidden representation; matrix X ∈ Rq×|V |transforms a character to a</context>
</contexts>
<marker>Mikolov, Zweig, 2012</marker>
<rawString>Tomas Mikolov and Geoffrey Zweig. 2012. Context Dependent Recurrent Neural Network Language Model. In Proceedings of 2012 IEEE Workshop on Spoken Language Technology, pages 234– 239, Miami, Florida.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Tomas Mikolov</author>
<author>Martin Karafi´at</author>
<author>Lukas Burget</author>
<author>Jan Cernock`y</author>
<author>Sanjeev Khudanpur</author>
</authors>
<title>Recurrent Neural Network based Language Model.</title>
<date>2010</date>
<booktitle>In Proceedings of INTERSPEECH,</booktitle>
<pages>1045--1048</pages>
<location>Makuhari, Japan.</location>
<marker>Mikolov, Karafi´at, Burget, Cernock`y, Khudanpur, 2010</marker>
<rawString>Tomas Mikolov, Martin Karafi´at, Lukas Burget, Jan Cernock`y, and Sanjeev Khudanpur. 2010. Recurrent Neural Network based Language Model. In Proceedings of INTERSPEECH, pages 1045–1048, Makuhari, Japan.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Tomas Mikolov</author>
<author>Anoop Deoras</author>
<author>Daniel Povey</author>
<author>Lukas Burget</author>
<author>Jan Cernocky</author>
</authors>
<title>Strategies for Training Large Scale Neural Network Language Models.</title>
<date>2011</date>
<booktitle>In Proceedings of ASRU 2011,</booktitle>
<pages>196--201</pages>
<location>Hilton Waikoloa Village, Big Island, Hawaii, US.</location>
<contexts>
<context position="5113" citStr="Mikolov et al., 2011" startWordPosition="822" endWordPosition="825">selection (“what to say”) and surface realization (“how to say”). Given a large collection of poems, we learn representations of individual characters, and their combinations into one or more lines as well as how these mutually reinforce and constrain each other. Our model generates lines in a poem probabilistically: it estimates the probability of the current line given the probability of all previously generated lines. We use a recurrent neural network to learn the representations of the lines generated so far which in turn serve as input to a recurrent language model (Mikolov et al., 2010; Mikolov et al., 2011b; Mikolov et al., 2011a) which generates the current line. In contrast to previous approaches (Greene et al., 2010; Jiang and Zhou, 2008), our generator makes no Markov assumptions about the dependencies of the words within a line and across lines. We evaluate our approach on the task of quatrain generation (see Table 1 for a human-written example). Experimental results show that our model outperforms competitive Chinese poetry generation systems using both automatic and manual evaluation methods. 2 Related Work Automated poetry generation has been a popular research topic over the past decad</context>
<context position="20178" citStr="Mikolov et al., 2011" startWordPosition="3366" endWordPosition="3369">hastic gradient descent. During training, the cross entropy error in the output layer of the RGM is back-propagated to its hidden and input layers, then to the RCM and finally to the CSM. The same number of hidden units (q = 200) is used throughout (i.e., in the RGM, RCM, and CSM). In our experiments all parameters were initialized randomly, with the exception of the word embedding matrix in the CSM which was initialized with word2vec embeddings (Mikolov et al., 2013) obtained from our poem corpus (see Section 4 for details on the data we used). To speed up training, we employed wordclassing (Mikolov et al., 2011b). To compute the probability of a character, we estimate the probability of its class and then multiply it by the probability of the character conditioned on the class. In our experiments we used 82 (square root of |V|) classes which we obtained by applying hierarchical clustering on character embeddings. This strategy outperformed better known frequency-based classing methods (Zweig and Makarychev, 2013) on our task. Our poem generator models content selection and lexical choice and their interaction, but does not have a strong notion of local coherence, as manifested in poetically felicito</context>
</contexts>
<marker>Mikolov, Deoras, Povey, Burget, Cernocky, 2011</marker>
<rawString>Tomas Mikolov, Anoop Deoras, Daniel Povey, Lukas Burget, and Jan Cernocky. 2011a. Strategies for Training Large Scale Neural Network Language Models. In Proceedings of ASRU 2011, pages 196– 201, Hilton Waikoloa Village, Big Island, Hawaii, US.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Tomas Mikolov</author>
<author>Stefan Kombrink</author>
<author>Lukas Burget</author>
<author>JH Cernocky</author>
<author>Sanjeev Khudanpur</author>
</authors>
<title>Extensions of Recurrent Neural Network Language Model.</title>
<date>2011</date>
<booktitle>In Proceedings of the 2011 IEEE International Conference on Acoustics, Speech and Signal Processing,</booktitle>
<pages>5528--5531</pages>
<location>Prague, Czech Republic.</location>
<contexts>
<context position="5113" citStr="Mikolov et al., 2011" startWordPosition="822" endWordPosition="825">selection (“what to say”) and surface realization (“how to say”). Given a large collection of poems, we learn representations of individual characters, and their combinations into one or more lines as well as how these mutually reinforce and constrain each other. Our model generates lines in a poem probabilistically: it estimates the probability of the current line given the probability of all previously generated lines. We use a recurrent neural network to learn the representations of the lines generated so far which in turn serve as input to a recurrent language model (Mikolov et al., 2010; Mikolov et al., 2011b; Mikolov et al., 2011a) which generates the current line. In contrast to previous approaches (Greene et al., 2010; Jiang and Zhou, 2008), our generator makes no Markov assumptions about the dependencies of the words within a line and across lines. We evaluate our approach on the task of quatrain generation (see Table 1 for a human-written example). Experimental results show that our model outperforms competitive Chinese poetry generation systems using both automatic and manual evaluation methods. 2 Related Work Automated poetry generation has been a popular research topic over the past decad</context>
<context position="20178" citStr="Mikolov et al., 2011" startWordPosition="3366" endWordPosition="3369">hastic gradient descent. During training, the cross entropy error in the output layer of the RGM is back-propagated to its hidden and input layers, then to the RCM and finally to the CSM. The same number of hidden units (q = 200) is used throughout (i.e., in the RGM, RCM, and CSM). In our experiments all parameters were initialized randomly, with the exception of the word embedding matrix in the CSM which was initialized with word2vec embeddings (Mikolov et al., 2013) obtained from our poem corpus (see Section 4 for details on the data we used). To speed up training, we employed wordclassing (Mikolov et al., 2011b). To compute the probability of a character, we estimate the probability of its class and then multiply it by the probability of the character conditioned on the class. In our experiments we used 82 (square root of |V|) classes which we obtained by applying hierarchical clustering on character embeddings. This strategy outperformed better known frequency-based classing methods (Zweig and Makarychev, 2013) on our task. Our poem generator models content selection and lexical choice and their interaction, but does not have a strong notion of local coherence, as manifested in poetically felicito</context>
</contexts>
<marker>Mikolov, Kombrink, Burget, Cernocky, Khudanpur, 2011</marker>
<rawString>Tomas Mikolov, Stefan Kombrink, Lukas Burget, JH Cernocky, and Sanjeev Khudanpur. 2011b. Extensions of Recurrent Neural Network Language Model. In Proceedings of the 2011 IEEE International Conference on Acoustics, Speech and Signal Processing, pages 5528–5531, Prague, Czech Republic.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Tomas Mikolov</author>
<author>Ilya Sutskever</author>
<author>Kai Chen</author>
<author>Greg S Corrado</author>
<author>Jeff Dean</author>
</authors>
<date>2013</date>
<booktitle>Distributed Representations of Words and Phrases and their Compositionality. In Advances in Neural Information Processing Systems,</booktitle>
<pages>3111--3119</pages>
<location>Lake Tahoe, Nevada, United States.</location>
<contexts>
<context position="9318" citStr="Mikolov et al., 2013" startWordPosition="1466" endWordPosition="1469"> used to generate the first line. Following lines are generated by taking into account the representations of all previously generated lines. using recurrent neural networks. Structural, semantic, and coherence constraints are captured naturally in our framework, through learning the representations of individual characters and their combinations. Secondly, generation proceeds by taking into account multi-sentential context rather than the immediately preceding sentence. Our work joins others in using continuous representations to express the meaning of words and phrases (Socher et al., 2012; Mikolov et al., 2013) and how these may be combined in a language modeling context (Mikolov and Zweig, 2012). More recently, continuous translation models based on recurrent neural networks have been proposed as a means to map a sentence from the source language to sentences in the target language (Auli et al., 2013; Kalchbrenner and Blunsom, 2013). These models are evaluated on the task of rescoring n-best lists of translations. We use neural networks more directly to perform the actual poem generation task. 3 The Poem Generator As common in previous work (Yan et al., 2013; He et al., 2012) we assume that our gen</context>
<context position="14066" citStr="Mikolov et al., 2013" startWordPosition="2260" endWordPosition="2263">he convolutional sentence model proposed in Kalchbrenner and Blunsom (2013) as it is n-gram based and does not make use of any parsing, POS-tagging or segmentation tools which are not available for Chinese poems. Their model computes a continuous representation for a sentence by sequentially merging neighboring vectors (see Figure 3). Let V denote the character vocabulary in our corpus; L ∈ Rq×|V |denotes a character embedding matrix whose columns correspond to character vectors (q represents the hidden unit size). Such vectors can be initialized randomly or obtained via a training procedure (Mikolov et al., 2013). Let w denote a character with index k; e(w) ∈ R|V|×1 is a vector with zero in all positions except e(w)k = 1; Tl ∈ Rq×Nl is the sentence representation in the lth layer, where Nl is the number of columns in the lth layer (Nl = 1 in the Figure 2: Generation of the (j + 1)th character wj+1 in the (i + 1)th line Si+1. The recurrent context model (RCM) takes i lines as input (represented by vectors v1,...,vi) and creates context vectors for the recurrent generation model (RGM). The RGM estimates the probability P(wj+1|w1: j,S1:i). top layer); Cl,n ∈ Rq×n is an array of weight matrices which comp</context>
<context position="20030" citStr="Mikolov et al., 2013" startWordPosition="3339" endWordPosition="3342">l is trained with back propagation through time (Rumelhart et al., 1988) with sentence length being the time step. The objective is minimized by stochastic gradient descent. During training, the cross entropy error in the output layer of the RGM is back-propagated to its hidden and input layers, then to the RCM and finally to the CSM. The same number of hidden units (q = 200) is used throughout (i.e., in the RGM, RCM, and CSM). In our experiments all parameters were initialized randomly, with the exception of the word embedding matrix in the CSM which was initialized with word2vec embeddings (Mikolov et al., 2013) obtained from our poem corpus (see Section 4 for details on the data we used). To speed up training, we employed wordclassing (Mikolov et al., 2011b). To compute the probability of a character, we estimate the probability of its class and then multiply it by the probability of the character conditioned on the class. In our experiments we used 82 (square root of |V|) classes which we obtained by applying hierarchical clustering on character embeddings. This strategy outperformed better known frequency-based classing methods (Zweig and Makarychev, 2013) on our task. Our poem generator models co</context>
</contexts>
<marker>Mikolov, Sutskever, Chen, Corrado, Dean, 2013</marker>
<rawString>Tomas Mikolov, Ilya Sutskever, Kai Chen, Greg S Corrado, and Jeff Dean. 2013. Distributed Representations of Words and Phrases and their Compositionality. In Advances in Neural Information Processing Systems, pages 3111–3119, Lake Tahoe, Nevada, United States.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Jeff Mitchell</author>
<author>Mirella Lapata</author>
</authors>
<title>Composition in Distributional Models of Semantics.</title>
<date>2010</date>
<journal>Cognitive Science,</journal>
<volume>34</volume>
<issue>8</issue>
<contexts>
<context position="13407" citStr="Mitchell and Lapata, 2010" startWordPosition="2153" endWordPosition="2156">V. More formally, to estimate P(wj+1|w1: j,S1:i) in Equation (1), we apply the following procedure: vi = CSM(Si) (2a) uij = RCM(v1:i, j) (2b) P(wj+1|w1: j,S1:i) = RGM(w1: j+1,u1: j i ) (2c) We obtain the probability of the (i + 1)th sentence P(Si+1|S1:i), by running the RGM in (2c) above m −1 times (see also Equation (1)). In the following, we describe how the different components of our model are obtained. 3.1 Convolutional Sentence Model (CSM) The CSM converts a poem line into a vector. In principle, any model that produces vector-based representations of phrases or sentences could be used (Mitchell and Lapata, 2010; Socher et al., 2012). We opted for the convolutional sentence model proposed in Kalchbrenner and Blunsom (2013) as it is n-gram based and does not make use of any parsing, POS-tagging or segmentation tools which are not available for Chinese poems. Their model computes a continuous representation for a sentence by sequentially merging neighboring vectors (see Figure 3). Let V denote the character vocabulary in our corpus; L ∈ Rq×|V |denotes a character embedding matrix whose columns correspond to character vectors (q represents the hidden unit size). Such vectors can be initialized randomly </context>
</contexts>
<marker>Mitchell, Lapata, 2010</marker>
<rawString>Jeff Mitchell and Mirella Lapata. 2010. Composition in Distributional Models of Semantics. Cognitive Science, 34(8):1388–1439.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Yael Netzer</author>
<author>David Gabay</author>
<author>Yoav Goldberg</author>
<author>Michael Elhadad</author>
</authors>
<title>Gaiku: Generating Haiku with Word Associations Norms.</title>
<date>2009</date>
<booktitle>In Proceedings of the Workshop on Computational Approaches to Linguistic Creativity,</booktitle>
<pages>32--39</pages>
<location>Boulder, Colorado.</location>
<contexts>
<context position="6185" citStr="Netzer et al. (2009)" startWordPosition="993" endWordPosition="996">using both automatic and manual evaluation methods. 2 Related Work Automated poetry generation has been a popular research topic over the past decades (see Colton et al. (2012) and the references therein). Most approaches employ templates to construct poems according to a set of constraints (e.g., rhyme, meter, stress, word frequency) in combination with corpus-based and lexicographic resources. For example, the Haiku poem generator presented in Wu et al. (2009) and Tosa et al. (2008) produces poems by expanding user queries with rules extracted from a corpus and additional lexical resources. Netzer et al. (2009) generate Haiku with Word Association Norms, Agirrezabal et al. (2013) compose Basque poems using patterns based on parts of speech and WordNet (Fellbaum, 1998), and Oliveira (2012) presents a generation algorithm for Portuguese which leverages semantic and grammar templates. A second line of research uses genetic algorithms for poem generation (Manurung, 2003; Manurung et al., 2012; Zhou et al., 2010). Manurung et al. (2012) argue that at a basic level all (machine-generated) poems must satisfy the constraints of grammaticality (i.e., a poem must syntactically well-formed), meaningfulness (i.</context>
</contexts>
<marker>Netzer, Gabay, Goldberg, Elhadad, 2009</marker>
<rawString>Yael Netzer, David Gabay, Yoav Goldberg, and Michael Elhadad. 2009. Gaiku: Generating Haiku with Word Associations Norms. In Proceedings of the Workshop on Computational Approaches to Linguistic Creativity, pages 32–39, Boulder, Colorado.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Franz Josef Och</author>
</authors>
<title>Minimum Error Rate Training in Statistical Machine Translation.</title>
<date>2003</date>
<booktitle>In Proceedings of the 41st Annual Meeting on Association for Computational Linguistics,</booktitle>
<pages>160--167</pages>
<location>Sapporo, Japan.</location>
<contexts>
<context position="22440" citStr="Och, 2003" startWordPosition="3723" endWordPosition="3724">ned with KenLM (Heafield, 2011). 3.5 Decoding Our decoder is a stack decoder similar to Koehn et al. (2003). In addition, it implements the tonal pattern and rhyming constraints necessary for generating well-formed Chinese quatrains. Once the first line in a poem is generated, its tonal pattern is determined. During decoding, phrases violating this pattern are ignored. As discussed in Section 1, the final characters of the second and the fourth lines must rhyme. We thus remove during decoding fourth lines whose final characters do not rhyme with the second line. Finally, we use MERT training (Och, 2003) to learn feature weights for the decoder. 4 Experimental Design Data We created a corpus of classical Chinese poems by collating several online resources: Tang Poems, Song Poems, Song Ci, Ming Poems, Qing Poems, and Tai Poems. The corpus consists of 284,899 poems in total. 78,859 of these are quatrains and were used for training and evaluating our model.1 Table 2 shows the different partitions of this dataset (POEMLM) into training (QTRAIN)2, validation (QVALID) and testing (QTEST). Half of the poems in QVALID and QTEST are 5-char quatrains and the other half are 7-char quatrains. All poems e</context>
</contexts>
<marker>Och, 2003</marker>
<rawString>Franz Josef Och. 2003. Minimum Error Rate Training in Statistical Machine Translation. In Proceedings of the 41st Annual Meeting on Association for Computational Linguistics, pages 160–167, Sapporo, Japan.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Hugo Gonc¸alo Oliveira</author>
</authors>
<title>PoeTryMe: a Versatile Platform for Poetry Generation.</title>
<date>2012</date>
<journal>Computational Creativity, Concept Invention, and General Intelligence,</journal>
<volume>1</volume>
<contexts>
<context position="6366" citStr="Oliveira (2012)" startWordPosition="1022" endWordPosition="1023">eferences therein). Most approaches employ templates to construct poems according to a set of constraints (e.g., rhyme, meter, stress, word frequency) in combination with corpus-based and lexicographic resources. For example, the Haiku poem generator presented in Wu et al. (2009) and Tosa et al. (2008) produces poems by expanding user queries with rules extracted from a corpus and additional lexical resources. Netzer et al. (2009) generate Haiku with Word Association Norms, Agirrezabal et al. (2013) compose Basque poems using patterns based on parts of speech and WordNet (Fellbaum, 1998), and Oliveira (2012) presents a generation algorithm for Portuguese which leverages semantic and grammar templates. A second line of research uses genetic algorithms for poem generation (Manurung, 2003; Manurung et al., 2012; Zhou et al., 2010). Manurung et al. (2012) argue that at a basic level all (machine-generated) poems must satisfy the constraints of grammaticality (i.e., a poem must syntactically well-formed), meaningfulness (i.e., a poem must convey a message that is meaningful under some interpretation) and poeticness (i.e., a poem must exhibit features that distinguishes it from non-poetic text, e.g., m</context>
</contexts>
<marker>Oliveira, 2012</marker>
<rawString>Hugo Gonc¸alo Oliveira. 2012. PoeTryMe: a Versatile Platform for Poetry Generation. Computational Creativity, Concept Invention, and General Intelligence, 1:21.</rawString>
</citation>
<citation valid="true">
<authors>
<author>David Rumelhart</author>
<author>Geoffrey Hinton</author>
<author>Ronald Williams</author>
</authors>
<title>Learning Representations by Backpropagating Errors.</title>
<date>1988</date>
<publisher>MIT Press,</publisher>
<location>Cambridge, MA, USA.</location>
<contexts>
<context position="19481" citStr="Rumelhart et al., 1988" startWordPosition="3241" endWordPosition="3244">long river. (5) P(Si+1|S1:i) = m−1 H j=1 674 The probability of the (j + 1)th word given the previous j words and the previous i lines is estimated by a softmax function: exp(yj+1,k) P(wj+1 = k|w1 :j, uj) = (8) ∑|V| k=1 exp(yj+1,k) We obtain P(Si+1|S1:i) by multiplying all the terms in the right hand-side of Equation (6). 3.4 Training The objective for training is the cross entropy errors of the predicted character distribution and the actual character distribution in our corpus. An l2 regularization term is also added to the objective. The model is trained with back propagation through time (Rumelhart et al., 1988) with sentence length being the time step. The objective is minimized by stochastic gradient descent. During training, the cross entropy error in the output layer of the RGM is back-propagated to its hidden and input layers, then to the RCM and finally to the CSM. The same number of hidden units (q = 200) is used throughout (i.e., in the RGM, RCM, and CSM). In our experiments all parameters were initialized randomly, with the exception of the word embedding matrix in the CSM which was initialized with word2vec embeddings (Mikolov et al., 2013) obtained from our poem corpus (see Section 4 for d</context>
</contexts>
<marker>Rumelhart, Hinton, Williams, 1988</marker>
<rawString>David Rumelhart, Geoffrey Hinton, and Ronald Williams. 1988. Learning Representations by Backpropagating Errors. MIT Press, Cambridge, MA, USA.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Richard Socher</author>
<author>Brody Huval</author>
<author>Christopher D Manning</author>
<author>Andrew Y Ng</author>
</authors>
<title>Semantic Compositionality through Recursive Matrix-Vector Spaces.</title>
<date>2012</date>
<booktitle>In Proceedings of the 2012 Joint Conference on Empirical Methods in Natural Language Processing and Computational Natural Language Learning,</booktitle>
<pages>1201--1211</pages>
<location>Jeju Island,</location>
<contexts>
<context position="9295" citStr="Socher et al., 2012" startWordPosition="1462" endWordPosition="1465">omy. Phrases are then used to generate the first line. Following lines are generated by taking into account the representations of all previously generated lines. using recurrent neural networks. Structural, semantic, and coherence constraints are captured naturally in our framework, through learning the representations of individual characters and their combinations. Secondly, generation proceeds by taking into account multi-sentential context rather than the immediately preceding sentence. Our work joins others in using continuous representations to express the meaning of words and phrases (Socher et al., 2012; Mikolov et al., 2013) and how these may be combined in a language modeling context (Mikolov and Zweig, 2012). More recently, continuous translation models based on recurrent neural networks have been proposed as a means to map a sentence from the source language to sentences in the target language (Auli et al., 2013; Kalchbrenner and Blunsom, 2013). These models are evaluated on the task of rescoring n-best lists of translations. We use neural networks more directly to perform the actual poem generation task. 3 The Poem Generator As common in previous work (Yan et al., 2013; He et al., 2012)</context>
<context position="13429" citStr="Socher et al., 2012" startWordPosition="2157" endWordPosition="2160">te P(wj+1|w1: j,S1:i) in Equation (1), we apply the following procedure: vi = CSM(Si) (2a) uij = RCM(v1:i, j) (2b) P(wj+1|w1: j,S1:i) = RGM(w1: j+1,u1: j i ) (2c) We obtain the probability of the (i + 1)th sentence P(Si+1|S1:i), by running the RGM in (2c) above m −1 times (see also Equation (1)). In the following, we describe how the different components of our model are obtained. 3.1 Convolutional Sentence Model (CSM) The CSM converts a poem line into a vector. In principle, any model that produces vector-based representations of phrases or sentences could be used (Mitchell and Lapata, 2010; Socher et al., 2012). We opted for the convolutional sentence model proposed in Kalchbrenner and Blunsom (2013) as it is n-gram based and does not make use of any parsing, POS-tagging or segmentation tools which are not available for Chinese poems. Their model computes a continuous representation for a sentence by sequentially merging neighboring vectors (see Figure 3). Let V denote the character vocabulary in our corpus; L ∈ Rq×|V |denotes a character embedding matrix whose columns correspond to character vectors (q represents the hidden unit size). Such vectors can be initialized randomly or obtained via a trai</context>
</contexts>
<marker>Socher, Huval, Manning, Ng, 2012</marker>
<rawString>Richard Socher, Brody Huval, Christopher D. Manning, and Andrew Y. Ng. 2012. Semantic Compositionality through Recursive Matrix-Vector Spaces. In Proceedings of the 2012 Joint Conference on Empirical Methods in Natural Language Processing and Computational Natural Language Learning, pages 1201–1211, Jeju Island, Korea.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Naoko Tosa</author>
<author>Hideto Obara</author>
<author>Michihiko Minoh</author>
</authors>
<title>Hitch Haiku: An Interactive Supporting System for Composing Haiku Poem How I Learned to Love the Bomb: Defcon and the Ethics of Computer Games.</title>
<date>2008</date>
<booktitle>In Proceedings of the 7th International Conference on Entertainment Computing,</booktitle>
<pages>209--216</pages>
<location>Pittsburgh, PA.</location>
<contexts>
<context position="6054" citStr="Tosa et al. (2008)" startWordPosition="971" endWordPosition="974">for a human-written example). Experimental results show that our model outperforms competitive Chinese poetry generation systems using both automatic and manual evaluation methods. 2 Related Work Automated poetry generation has been a popular research topic over the past decades (see Colton et al. (2012) and the references therein). Most approaches employ templates to construct poems according to a set of constraints (e.g., rhyme, meter, stress, word frequency) in combination with corpus-based and lexicographic resources. For example, the Haiku poem generator presented in Wu et al. (2009) and Tosa et al. (2008) produces poems by expanding user queries with rules extracted from a corpus and additional lexical resources. Netzer et al. (2009) generate Haiku with Word Association Norms, Agirrezabal et al. (2013) compose Basque poems using patterns based on parts of speech and WordNet (Fellbaum, 1998), and Oliveira (2012) presents a generation algorithm for Portuguese which leverages semantic and grammar templates. A second line of research uses genetic algorithms for poem generation (Manurung, 2003; Manurung et al., 2012; Zhou et al., 2010). Manurung et al. (2012) argue that at a basic level all (machin</context>
</contexts>
<marker>Tosa, Obara, Minoh, 2008</marker>
<rawString>Naoko Tosa, Hideto Obara, and Michihiko Minoh. 2008. Hitch Haiku: An Interactive Supporting System for Composing Haiku Poem How I Learned to Love the Bomb: Defcon and the Ethics of Computer Games. In Proceedings of the 7th International Conference on Entertainment Computing, pages 209–216, Pittsburgh, PA.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Li Wang</author>
</authors>
<title>A Summary of Rhyming Constraints of Chinese Poems (Shi Ci Ge Lv Gai Yao).</title>
<date>2002</date>
<publisher>Beijing Press,</publisher>
<contexts>
<context position="2788" citStr="Wang, 2002" startWordPosition="459" endWordPosition="460">e of a 5-char quatrain exhibiting one of the most popular tonal patterns. The tone of each character is shown at the end of each line (within parentheses); P and Z are shorthands for Ping and Ze tones, respectively; * indicates that the tone is not fixed and can be either. Rhyming characters are shown in boldface. whereas there are no rhyming constraints for the third line. Moreover, poems must follow a prescribed tonal pattern. In traditional Chinese, every character has one tone, Ping (level tone) or Ze (downward tone). The poem in Table 1 exemplifies one of the most popular tonal patterns (Wang, 2002). Besides adhering to the above formal criteria, poems must exhibit concise and accurate use of language, engage the reader/hearer, stimulate their imagination, and bring out their feelings. In this paper we are concerned with generating traditional Chinese poems automatically. Although computers are no substitute for poetic creativity, they can analyze very large online text repositories of poems, extract statistical patterns, maintain them in memory and use them to generate many possible variants. Furthermore, while amateur poets may struggle to remember and apply formal tonal and structural</context>
<context position="23809" citStr="Wang (2002)" startWordPosition="3938" endWordPosition="3939">TRAIN (6,773 in total) were replaced by &lt;R&gt; to reduce data sparsity. 675 Poems Lines Characters QTRAIN 74,809 299,236 2,004,460 QVALID 2,000 8,000 48,000 QTEST 2,050 8,200 49,200 POEMLM 280,849 2,711,034 15,624,283 Models Perplexity KN5 172 RNNLM 145 RNNPG 93 Table 3: Perplexities for different models. Table 2: Dataset partitions of our poem corpus. and QTEST were used for training the characterbased language models (see row POEMLM in Table 2). We also trained word2vec embeddings on POEMLM. In our experiments, we generated quatrains following the eight most popular tonal patterns according to Wang (2002). Perplexity Evaluation Evaluation of machinegenerated poetry is a notoriously difficult task. Our evaluation studies were designed to assess Manurung et al.’s (2012) criteria of grammaticality, meaningfulness, and poeticness. As a sanity check, we first measured the perplexity of our model with respect to the goldstandard. Intuitively, a better model should assign larger probability (and therefore lower perplexity) to goldstandard poems. BLEU-based Evaluation We also used BLEU to evaluate our model’s ability to generate the second, third and fourth line given previous goldstandard lines. A pr</context>
</contexts>
<marker>Wang, 2002</marker>
<rawString>Li Wang. 2002. A Summary of Rhyming Constraints of Chinese Poems (Shi Ci Ge Lv Gai Yao). Beijing Press, 2002.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Xiaofeng Wu</author>
<author>Naoko Tosa</author>
<author>Ryohei Nakatsu</author>
</authors>
<title>New Hitch Haiku: An Interactive Renku Poem Composition Supporting Tool Applied for Sightseeing Navigation System.</title>
<date>2009</date>
<booktitle>In Proceedings of the 8th International Conference on Entertainment Computing,</booktitle>
<pages>191--196</pages>
<location>Paris, France.</location>
<contexts>
<context position="6031" citStr="Wu et al. (2009)" startWordPosition="966" endWordPosition="969">eration (see Table 1 for a human-written example). Experimental results show that our model outperforms competitive Chinese poetry generation systems using both automatic and manual evaluation methods. 2 Related Work Automated poetry generation has been a popular research topic over the past decades (see Colton et al. (2012) and the references therein). Most approaches employ templates to construct poems according to a set of constraints (e.g., rhyme, meter, stress, word frequency) in combination with corpus-based and lexicographic resources. For example, the Haiku poem generator presented in Wu et al. (2009) and Tosa et al. (2008) produces poems by expanding user queries with rules extracted from a corpus and additional lexical resources. Netzer et al. (2009) generate Haiku with Word Association Norms, Agirrezabal et al. (2013) compose Basque poems using patterns based on parts of speech and WordNet (Fellbaum, 1998), and Oliveira (2012) presents a generation algorithm for Portuguese which leverages semantic and grammar templates. A second line of research uses genetic algorithms for poem generation (Manurung, 2003; Manurung et al., 2012; Zhou et al., 2010). Manurung et al. (2012) argue that at a </context>
</contexts>
<marker>Wu, Tosa, Nakatsu, 2009</marker>
<rawString>Xiaofeng Wu, Naoko Tosa, and Ryohei Nakatsu. 2009. New Hitch Haiku: An Interactive Renku Poem Composition Supporting Tool Applied for Sightseeing Navigation System. In Proceedings of the 8th International Conference on Entertainment Computing, pages 191–196, Paris, France.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Rui Yan</author>
<author>Han Jiang</author>
<author>Mirella Lapata</author>
<author>Xueqiang Lv Shou-De Lin</author>
<author>Xiaoming Li</author>
</authors>
<title>I, Poet: Automatic Chinese Poetry Composition Through a Generative Summarization Framework Under Constrained Optimization.</title>
<date>2013</date>
<booktitle>In Proceedings of the 23rd International Joint Conference on Artificial Intelligence,</booktitle>
<pages>2197--2203</pages>
<location>Beijing, China.</location>
<marker>Yan, Jiang, Lapata, Shou-De Lin, Li, 2013</marker>
<rawString>Rui Yan, Han Jiang, Mirella Lapata, Shou-De Lin, Xueqiang Lv, and Xiaoming Li. 2013. I, Poet: Automatic Chinese Poetry Composition Through a Generative Summarization Framework Under Constrained Optimization. In Proceedings of the 23rd International Joint Conference on Artificial Intelligence, pages 2197–2203, Beijing, China.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Wei You Cheng-Le Zhou</author>
<author>Xiaojun Ding</author>
</authors>
<title>Genetic Algorithm and its Implementation of Automatic Generation of Chinese SongCi.</title>
<date>2010</date>
<journal>Journal of Software,</journal>
<pages>427--437</pages>
<marker>Cheng-Le Zhou, Ding, 2010</marker>
<rawString>Cheng-Le Zhou, Wei You, and Xiaojun Ding. 2010. Genetic Algorithm and its Implementation of Automatic Generation of Chinese SongCi. Journal of Software, pages 427–437.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Geoffrey Zweig</author>
<author>Konstantin Makarychev</author>
</authors>
<title>Speed Regularization and Optimality in Word Classing.</title>
<date>2013</date>
<booktitle>In Proceedings of the 2014 IEEE International Conference on Acoustics, Speech, and Signal Processing,</booktitle>
<pages>8237--8241</pages>
<location>Florence, Italy.</location>
<contexts>
<context position="20588" citStr="Zweig and Makarychev, 2013" startWordPosition="3431" endWordPosition="3434">which was initialized with word2vec embeddings (Mikolov et al., 2013) obtained from our poem corpus (see Section 4 for details on the data we used). To speed up training, we employed wordclassing (Mikolov et al., 2011b). To compute the probability of a character, we estimate the probability of its class and then multiply it by the probability of the character conditioned on the class. In our experiments we used 82 (square root of |V|) classes which we obtained by applying hierarchical clustering on character embeddings. This strategy outperformed better known frequency-based classing methods (Zweig and Makarychev, 2013) on our task. Our poem generator models content selection and lexical choice and their interaction, but does not have a strong notion of local coherence, as manifested in poetically felicitous line-to-line transitions. In contrast, machine translation models (Jiang and Zhou, 2008) have been particularly successful at generating adjacent lines (couplets). To enhance coherence, we thus interpolate our model with two machine translation features (i.e., inverted phrase translation model feature and inverted lexical weight feature). Also note, that in our model surface generation depends on the las</context>
</contexts>
<marker>Zweig, Makarychev, 2013</marker>
<rawString>Geoffrey Zweig and Konstantin Makarychev. 2013. Speed Regularization and Optimality in Word Classing. In Proceedings of the 2014 IEEE International Conference on Acoustics, Speech, and Signal Processing, pages 8237–8241, Florence, Italy.</rawString>
</citation>
</citationList>
</algorithm>
</algorithms>