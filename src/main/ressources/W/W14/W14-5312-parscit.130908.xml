<?xml version="1.0" encoding="UTF-8"?>
<algorithms version="110505">
<algorithm name="SectLabel" version="110505">
<variant no="0" confidence="0.007826">
<title confidence="0.985141">
Statistical Morph Analyzer (SMA++) for Indian Languages
</title>
<author confidence="0.958715">
Saikrishna Srirampur Ravi Chandibhamar Radhika Mamidi
</author>
<affiliation confidence="0.934923">
IIIT Hyderabad IIIT Hyderabad IIIT Hyderabad
</affiliation>
<address confidence="0.374588">
saikrishna.srirampur chandibhamar.ravi radhika.mamidi
</address>
<email confidence="0.979829">
@research.iiit.ac.in @students.iiit.ac.in @iiit.ac.in
</email>
<sectionHeader confidence="0.993165" genericHeader="abstract">
Abstract
</sectionHeader>
<bodyText confidence="0.999831090909091">
Statistical morph analyzers have proved to be highly accurate while being comparatively easier to
maintain than rule based approaches. Our morph analyzer (SMA++) is an improvement over the
statistical morph analyzer (SMA) described in Malladi and Mannem (2013). SMA++ predicts the
gender, number, person, case (GNPC) and the lemma (L) of a given token. We modified the SMA
in Malladi and Mannem (2013), by adding some rich machine learning features. The feature set
was chosen specifically to suit the characteristics of Indian Languages. In this paper we apply
SMA++ to four Indian languages viz. Hindi, Urdu, Telugu and Tamil. Hindi and Urdu belong
to the Indic1 language family. Telugu and Tamil belong to the Dravidian2 language family. We
compare SMA++ with some state-of-art statistical morph analyzers viz. Morfette in Chrupała et
al. (2008) and SMA in Malladi and Mannem (2013). In all four languages, our system performs
better than the above mentioned state-of-art SMAs.
</bodyText>
<sectionHeader confidence="0.998793" genericHeader="introduction">
1 Introduction
</sectionHeader>
<bodyText confidence="0.999801538461538">
Morphological analysis for Indian Languages (ILs) is defined as the analysis of a word in terms of its
lemma (L), gender (G), number (N), person (P), case (C), vibhakti3, tense, aspect and modality. A tool
which predicts Morph Analysis of a word is called a Morph Analyzer (MA).
Statistical Morph Analyzer (SMA) is an MA which uses machine learning to predict the morph infor-
mation . Using the training data and the feature-set, statistical models are formed. These models help to
predict the morph-analysis of the test data. This works for all words, including out of vocabulary (OOV)
words. SMA is language independent. We chose Indian Languages for our study and built an SMA
which is targeted for different ILs.
Indian languages are lexically and grammatically similar. Lexical borrowing4 occurs between languages.
Gramatically, there are many similarities. Indian languages are synthetic5; derivational and inflectional
morphologies result in the formation of complex words by stringing two or more morphemes. ILs pre-
dominantly have subject-object-verb (SOV) word order. They show agreement6 among words. We cap-
tured such type of characteristics, by building a robust feature set.
</bodyText>
<sectionHeader confidence="0.999834" genericHeader="related work">
2 Related Work
</sectionHeader>
<bodyText confidence="0.997846833333333">
Traditionally, morphological analysis for Indian languages has been done using the rule based approach.
For Hindi, the MA by Bharati et al. (1995) is most widely used among the NLP researchers in the
Indian Community. Goyal and Lehal (2008) and Kanuparthi et al. (2012) MAs are advanced versions
of the Bharati et al. (1995)’s analyzer. Kanuparthi et al. (2012) built a derivational MA for Hindi by
introducing a layer over the Bharati et al. (1995)’s MA .It identifies 22 derivational suffixes which help
in providing derivational analysis for the word whose suffix matches with one of these 22 suffixes.
</bodyText>
<footnote confidence="0.998452444444444">
1The Indic languages are the dominant language family of the Indian subcontinent, generally spoken in the regions of
northern India and Pakistan
2The Dravidian languages are spoken mainly in southern India
3Vibhakti is a Sanskrit grammatical term that encompasses post-positionals and case endings for nouns, as well as inflection
and auxiliaries for verbs. It is also referred as case-marker
4A word from one language that has been adapted for use in another is a borrowed word.
5a synthetic language is a language with a high morpheme-per-word ratio
6Agreement or Concord happens when a word changes form depending on the other words to which it relates
This work is licenced under a Creative Commons Attribution 4.0 International License. Page numbers and proceedings footer
</footnote>
<page confidence="0.883986">
103
</page>
<bodyText confidence="0.710364">
are added by the organizers. License details: http://creativecommons.org/licenses/by/4.0/
</bodyText>
<note confidence="0.68222">
Proceedings of the First Workshop on Applying NLP Tools to Similar Languages, Varieties and Dialects, pages 103–109,
Dublin, Ireland, August 23 2014.
</note>
<bodyText confidence="0.999235444444444">
There have not been many updates in the rule based analyzers and the problem of not predicting OOV
words is still a significant one. SMA in Malladi and Mannem (2013) is a data-driven MA which focuses
primarily on Hindi.
For Urdu, B¨ogel et al. (2007) proposes an approach which uses Finite State Transducers. It introduces
and discusses the issues that arise in the process of building finite-state MA for Urdu. For Telugu,
Sunitha and Kalyani (2009) propose an approach of improving the existing rule based Telugu MA. They
did this, using possible decompositions of the word, inflected by many morphemes. SMA in Malladi and
Mannem (2013) evaluates the results for Urdu and Telugu as well. Not much research has been done in
Morphological Analysis for Tamil.
</bodyText>
<sectionHeader confidence="0.950271" genericHeader="method">
3 Our Approach
</sectionHeader>
<subsectionHeader confidence="0.998574">
3.1 Feature Set
</subsectionHeader>
<bodyText confidence="0.985177">
The feature-set was chosen specifically to suit the Indian Languages. The following are the features
used:
</bodyText>
<listItem confidence="0.9817982">
(i) Suffixes : Indian languages show inflectional morphology. The inflectional morphemes carry the
G,N,P and C of a word. These morphemes generally occur in the form of suffixes. Hence, to capture
the inflectional behaviour of ILs we considered the suffixes as a feature for the ML task. We considered
suffixes whose length was maximum 7 characters.
(ii) Previous morph tags7 and next morph tags : Agreement is an important characteristic of ILs.
Through agreement, GNPC of a token may percolate to the other tokens. An example to this is, if the
subject (noun) is masculine, then the verb form should also be masculine. To capture agreement, we
considered features which carried the GNPC of the neighbouring words. Previous morph tags feature
captures predicted morph tag of previous 3 tokens. Next morph tags feature captures the set of morph
tags of the next token, if found in the training corpus.
(iii) Word Forms: ILs are morphologically rich languages. Words carry rich information regarding
GNPC. To capture this characteristic we considered three features relating to word forms. word present
captures the word form of the present token. word previous captures the word form of the previous token.
word next captures the word form of the next token.
(iv) Part of Speech (POS) : POS is one of the of the fundamental ML feature of any NLP task. Based
on the POS of the word, the set of possible inflections can be found. For example, verbs have a set of
inflections and nouns have another set. To capture such information we included POS in the feature-set.
(v) Other features : Features such as length of the token and character types in the token (eg. numbers,
alphabets and so on) have also been considered.
The Support Vector Machine (SVM) (using linear classifier) was used for the ML task .
</listItem>
<subsectionHeader confidence="0.999797">
3.2 Choosing Class Labels
</subsectionHeader>
<bodyText confidence="0.995244727272727">
For the ML task, the class-labels for G, N, P, C were chosen from the training data itself. For lemma, the
class-labels were formed based on the edit-distance8 operations required to convert the given token to its
lemma. This idea was inspired by Chrupała (2006), who introduced the concept of edit-operations9 for
lemmatization.
The Algorithm is explained using an example. Consider the token crying. The lemma for crying is cry.
Step 1: The token and its lemma are reversed. crying becomes gniyrc and cry becomes yrc.
Step 2: Note the edit operations required to convert reversed token to the reversed lemma. To convert
gniyrc to yrc we need to delete the characters at the 1st, 2nd and 3rd indices. Hence the edit operations
would be [d 1, d 2, d 3], where ’d’ represents delete operation.
Step 3: The set of edit operations would form the class-label. [d 1, d 2, d 3] would be the class-label and
would be added to the set of class-labels.
</bodyText>
<footnote confidence="0.996343">
7The possible values of each G, N, P, C and L form the morph tags. eg. ’m’ (masculine) is a morph tag for gender.
8Edit distance is a way of quantifying how dissimilar two strings (e.g., words) are to one another by counting the minimum
number of operations required to transform one string into the other.
9The add, delete and replace operations required to convert one string to another
</footnote>
<page confidence="0.996972">
104
</page>
<bodyText confidence="0.998677">
Similarly, the class-label for the token playing and the lemma play would be [d 1, d 2, d 3]. By this,
playing - play and crying - cry have the same class label, because they have the common suffix -ing.
</bodyText>
<sectionHeader confidence="0.999343" genericHeader="method">
4 Experiments
</sectionHeader>
<bodyText confidence="0.895832">
Experiments were conducted for 4 ILs, viz. Hindi, Urdu, Telugu and Tamil. For Hindi, the Hindi
Treebank (HTB) released as part of the 2012 Hindi Parsing Shared Task (Sharma et al., 2012) was used
for the ML task. The statistical models were tuned on development data and evaluated on test data.
Table 1. shows the HTB statistics.
For Urdu, the Urdu Treebank (UTB) released as a part of the 2012 Proceedings of TLT (Bhat and
Sharma (2012)) was used for evaluation. Table 2. represents the UTB statistics. For Telugu, the Telugu
Treebank (TTB) released for ICON 2010 Shared Task (Husain et al. (2010)) was used for evaluation.
</bodyText>
<tableCaption confidence="0.648011">
Table 3. represents the TTB statistics. For Tamil, the Tamil Treebank (TaTB) released by the The Indian
Languages Machine Translation (ILMT)10 project was used for evaluation. Table 4. represents the TaTB
statistics.
</tableCaption>
<table confidence="0.99931775">
Data #Sentences #Words
Training 12,041 268,096
Development 1,233 26,416
Test 1,828 39,775
</table>
<tableCaption confidence="0.979043">
Table 1: HTB Statistics.
</tableCaption>
<table confidence="0.999667333333333">
Data #Sentences #Words
Training 5,700 159,743
Test 1,453 39,803
</table>
<tableCaption confidence="0.887922">
Table 2: UTB Statistics.
</tableCaption>
<table confidence="0.999572666666667">
Data #Sentences #Words
Training 1300 5125
Test 150 600
</table>
<tableCaption confidence="0.997421">
Table 3: TTB Statistics.
</tableCaption>
<footnote confidence="0.423282">
10This consortium project is funded by Ministry of Communication and Information Technology, Technology Development
for Indian Languages, Government Of India.
</footnote>
<page confidence="0.94911">
105
</page>
<table confidence="0.993995333333333">
Data #Sentences #Words
Training 75 682
Test 25 271
</table>
<tableCaption confidence="0.997255">
Table 4: TaTB Statistics.
</tableCaption>
<sectionHeader confidence="0.999677" genericHeader="evaluation">
5 Results
</sectionHeader>
<bodyText confidence="0.999968333333333">
The feature-set, which was specifically chosen for ILs, contributed to high accuracies. The results are
shown for 4 Indian Languages. The results for each of L, G, N, P and C are shown individually, as well
as in combination.
</bodyText>
<subsectionHeader confidence="0.968323">
5.1 Hindi
</subsectionHeader>
<bodyText confidence="0.9995184">
The results are presented all five L ,G, N, P and C. The results are compared to 3 MAs viz. the traditional
Rule Based MA (RBA) for Hindi, Morfette (M) in Chrupała et al. (2008) and SMA in Malladi and Man-
nem (2013) (SMA-M). There are two divisions for results. One for the Overall test data and other for the
Out of Vocabulary (OOV) test data. SMA++ out performed other three MAs in almost all combinations.
The results for OOV data are more pronounced. Table 5. shows the Hindi results.
</bodyText>
<table confidence="0.999296916666667">
Analysis Test Data - Overall (%) Test Data - OOV (%)
RBA M SMA-M SMA++ RBA M SMA-M SMA++
L 86.69 94.14 95.84 98.43 82.48 90.30 89.51 93.07
G 79.59 95.05 96.19 96.21 44.06 72.03 82.65 83.11
N 80.50 94.09 95.37 95.47 47.56 84.89 90.44 92.81
P 84.13 94.88 96.38 96.28 53.89 84.76 94.85 96.17
C 81.20 93.91 95.32 95.43 47.36 80.21 88.52 89.45
L+C 72.06 88.56 91.39 94.01 44.66 72.89 79.09 82.92
G+N+P 73.81 88.36 91.11 90.36 38.58 62.33 76.52 77.24
G+N+P+C 70.87 84.43 87.78 88.51 35.95 55.74 69.99 72.36
L+G+N+P 66.28 83.44 87.51 89.26 38.46 57.85 69.13 72.82
L+G+N+P+C 63.41 79.73 84.25 85.87 38.49 51.52 63.06 65.96
</table>
<tableCaption confidence="0.998267">
Table 5: Hindi Results
</tableCaption>
<subsectionHeader confidence="0.990271">
5.2 Urdu
</subsectionHeader>
<bodyText confidence="0.999922">
The results are presented for L, G, N, P and C. The results are compared to 2 MAs viz. Morfette (M) in
Chrupała et al. (2008) and SMA in Malladi and Mannem (2013) (SMA-M). Results are shown for both
Overall test data and OOV test data. Even in Urdu, SMA++ out performed other two MAs in most of the
combinations. Table 6. presents the results in comparison with Morfette (M) and Table 7. presents the
results in comparison with SMA-M.
</bodyText>
<page confidence="0.990277">
106
</page>
<table confidence="0.999406666666667">
Analysis Test Data - Overall (%) Test Data - OOV (%)
M SMA++ M SMA++
L 93.65 95.34 87.54 89.21
G 90.39 93.79 79.40 90.35
N 92.38 95.66 85.36 94.50
P 93.93 97.07 86.56 98.39
C 87.99 90.92 76.08 84.07
L+C 82.94 86.93 67.25 75.66
G+N+P 84.52 89.43 70.32 86.09
G+N+P+C 77.01 82.17 58.54 73.69
L+G+N+P 80.12 86.07 64.14 78.93
L+G+N+P+C 73.11 79.16 53.30 67.98
</table>
<tableCaption confidence="0.945039">
Table 6: Urdu Results for SMA++ and M
</tableCaption>
<table confidence="0.999739166666667">
Analysis Test Data - Overall (%) Test Data - OOV (%)
SMA-M SMA++ SMA-M SMA++
G 89.14 93.79 88.18 90.35
N 91.62 95.66 91.35 94.50
P 93.37 97.07 95.53 98.39
C 85.49 90.92 79.01 84.07
</table>
<tableCaption confidence="0.998824">
Table 7: Urdu Results for SMA++ and SMA-M
</tableCaption>
<subsectionHeader confidence="0.995689">
5.3 Telugu
</subsectionHeader>
<bodyText confidence="0.985675666666667">
The results are presented for G, N, P and C. The results are compared to 2 MAs viz. Morfette (M) in
Chrupała et al. (2008) and SMA in Malladi and Mannem (2013) (SMA-M). Results are presented for
both Overall test data and OOV test data. SMA++ significantly out performed Morfette (M). The results
of Overall Data for SMA++ and SMA-M are very close, but more importantly the results of OOV data
for SMA++ are higher than SMA-M. Table 8. presents the results in comparison with Morfette (M) and
Table 9. presents the results in comparison with SMA-M.
</bodyText>
<table confidence="0.998555125">
Analysis Test Data - Overall (%) Test Data - OOV (%)
M SMA++ M SMA++
G 95.49 96.33 87.82 89.85
N 87.31 90.48 65.48 77.67
P 94.49 94.49 86.80 86.80
C 94.49 95.66 84.26 90.36
G+N+P 85.48 88.81 60.91 74.62
G+N+P+C 84.14 86.81 57.36 70.56
</table>
<tableCaption confidence="0.998126">
Table 8: Telugu Results for SMA++ and M
</tableCaption>
<page confidence="0.907006">
107
</page>
<table confidence="0.9987055">
Analysis Test Data - Overall (%) Test Data - OOV (%)
SMA-M SMA++ SMA-M SMA++
G 96.49 96.33 89.85 89.85
N 90.65 90.48 75.13 77.67
P 94.82 94.49 85.79 86.80
C 96.49 95.66 89.34 90.36
</table>
<tableCaption confidence="0.998699">
Table 9: Telugu Results for SMA++ and SMA-M
</tableCaption>
<subsectionHeader confidence="0.930009">
5.4 Tamil
</subsectionHeader>
<bodyText confidence="0.996123333333333">
The results are presented for G, N, P and C. The results are compared to Morfette (M) in Chrupała et al.
(2008). SMA++ out performs Morfette (M). Table 10. presents the results in comparison with Morfette
(M).
</bodyText>
<table confidence="0.999039">
Analysis Test Data - Overall (%) Test Data - OOV (%)
M SMA++ M SMA++
G 90.40 91.14 85.18 91.36
N 88.93 90.04 83.95 87.04
P 98.15 98.89 96.91 98.14
C 87.82 94.46 80.86 91.98
G+N+P 80.81 82.66 70.99 80.25
G+N+P+C 76.38 78.97 64.20 74.07
</table>
<tableCaption confidence="0.9927">
Table 10: Tamil Results
</tableCaption>
<sectionHeader confidence="0.995941" genericHeader="conclusions">
6 Conclusions and Future Work:
</sectionHeader>
<bodyText confidence="0.9998125">
For all the four ILs, SMA++ out performs other SMAs. For Hindi, the L+G+N+P+C accuracy was
85.87%. For Urdu, the L+G+N+P+C accuracy was 79.16%. For Telugu, G+N+P+C accuracy was
86.81% and for Tamil it was 78.97%. These high values show that SMA++ is a marked improvement
over the SMA in Malladi and Mannem (2013) . We studied two families of ILs, viz. Indic and Dravidian,
because most of the ILs fall into these two groups. We plan to run SMA++ to predict Lemma in Telugu
and Tamil. We plan to extend our work to European Languages such as Polish, German, French etc. We
are currently working on the error analysis of our system. In future, we plan to deploy SMA++ for the
ILMT project.
</bodyText>
<sectionHeader confidence="0.999275" genericHeader="references">
References
</sectionHeader>
<reference confidence="0.995465818181818">
Akshar Bharati, Vineet Chaitanya, Rajeev Sangal, and KV Ramakrishnamacharyulu. 1995. Natural language
processing: a Paninian perspective. Prentice-Hall of India New Delhi.
Riyaz Ahmad Bhat and Dipti Misra Sharma. 2012. A dependency treebank of urdu and its evaluation. In Proceed-
ings of the Sixth Linguistic Annotation Workshop, pages 157–165. Association for Computational Linguistics.
Tina B¨ogel, Miriam Butt, Annette Hautli, and Sebastian Sulger. 2007. Developing a finite-state morphological
analyzer for urdu and hindi. Finite State Methods and Natural Language Processing, page 86.
Grzegorz Chrupała, Georgiana Dinu, and Josef Van Genabith. 2008. Learning morphology with morfette.
Grzegorz Chrupała. 2006. Simple data-driven contextsensitive lemmatization. Procesamiento del Lenguaje Natu-
ral, 37:121–127.
Vishal Goyal and Gurpreet Singh Lehal. 2008. Hindi morphological analyzer and generator. In Emerging Trends
in Engineering and Technology, 2008. ICETET’08. First International Conference on, pages 1156–1159. IEEE.
</reference>
<page confidence="0.987158">
108
</page>
<reference confidence="0.998054142857143">
Samar Husain, Prashanth Mannem, Bharat Ram Ambati, and Phani Gadde. 2010. The icon-2010 tools contest
on indian language dependency parsing. Proceedings of ICON-2010 Tools Contest on Indian Language Depen-
dency Parsing, ICON, 10:1–8.
Nikhil Kanuparthi, Abhilash Inumella, and Dipti Misra Sharma. 2012. Hindi derivational morphological ana-
lyzer. In Proceedings of the Twelfth Meeting of the Special Interest Group on Computational Morphology and
Phonology, pages 10–16. Association for Computational Linguistics.
Deepak Kumar Malladi and Prashanth Mannem. 2013. Context based statistical morphological analyzer and
its effect on hindi dependency parsing. In Fourth Workshop on Statistical Parsing of Morphologically Rich
Languages, volume 12, page 119.
Dipti Misra Sharma, Prashanth Mannem, Joseph vanGenabith, Sobha Lalitha Devi, Radhika Mamidi, and Ranjani
Parthasarathi, editors. 2012. Proceedings of the Workshop on Machine Translation and Parsing in Indian
Languages. The COLING 2012 Organizing Committee, Mumbai, India, December.
KVN Sunitha and N Kalyani. 2009. A novel approach to improve rule based telugu morphological analyzer. In
Nature &amp; Biologically Inspired Computing, 2009. NaBIC 2009. World Congress on, pages 1649–1652. IEEE.
</reference>
<page confidence="0.998885">
109
</page>
</variant>
</algorithm>
<algorithm name="ParsHed" version="110505">
<variant no="0" confidence="0.724810">
<title confidence="0.999734">Statistical Morph Analyzer (SMA++) for Indian Languages</title>
<author confidence="0.989628">Saikrishna Srirampur Ravi Chandibhamar Radhika Mamidi</author>
<affiliation confidence="0.757833">IIIT Hyderabad IIIT Hyderabad IIIT Hyderabad</affiliation>
<abstract confidence="0.996117714285714">saikrishna.srirampur chandibhamar.ravi radhika.mamidi @research.iiit.ac.in @students.iiit.ac.in @iiit.ac.in Abstract Statistical morph analyzers have proved to be highly accurate while being comparatively easier to maintain than rule based approaches. Our morph analyzer (SMA++) is an improvement over the statistical morph analyzer (SMA) described in Malladi and Mannem (2013). SMA++ predicts the gender, number, person, case (GNPC) and the lemma (L) of a given token. We modified the SMA in Malladi and Mannem (2013), by adding some rich machine learning features. The feature set was chosen specifically to suit the characteristics of Indian Languages. In this paper we apply SMA++ to four Indian languages viz. Hindi, Urdu, Telugu and Tamil. Hindi and Urdu belong the language family. Telugu and Tamil belong to the language family. We compare SMA++ with some state-of-art statistical morph analyzers viz. Morfette in Chrupała et al. (2008) and SMA in Malladi and Mannem (2013). In all four languages, our system performs better than the above mentioned state-of-art SMAs.</abstract>
</variant>
</algorithm>
<algorithm name="ParsCit" version="110505">
<citationList>
<citation valid="true">
<authors>
<author>Akshar Bharati</author>
<author>Vineet Chaitanya</author>
<author>Rajeev Sangal</author>
<author>KV Ramakrishnamacharyulu</author>
</authors>
<title>Natural language processing: a Paninian perspective. Prentice-Hall of India</title>
<date>1995</date>
<location>New Delhi.</location>
<contexts>
<context position="2615" citStr="Bharati et al. (1995)" startWordPosition="388" endWordPosition="391">guages are lexically and grammatically similar. Lexical borrowing4 occurs between languages. Gramatically, there are many similarities. Indian languages are synthetic5; derivational and inflectional morphologies result in the formation of complex words by stringing two or more morphemes. ILs predominantly have subject-object-verb (SOV) word order. They show agreement6 among words. We captured such type of characteristics, by building a robust feature set. 2 Related Work Traditionally, morphological analysis for Indian languages has been done using the rule based approach. For Hindi, the MA by Bharati et al. (1995) is most widely used among the NLP researchers in the Indian Community. Goyal and Lehal (2008) and Kanuparthi et al. (2012) MAs are advanced versions of the Bharati et al. (1995)’s analyzer. Kanuparthi et al. (2012) built a derivational MA for Hindi by introducing a layer over the Bharati et al. (1995)’s MA .It identifies 22 derivational suffixes which help in providing derivational analysis for the word whose suffix matches with one of these 22 suffixes. 1The Indic languages are the dominant language family of the Indian subcontinent, generally spoken in the regions of northern India and Paki</context>
</contexts>
<marker>Bharati, Chaitanya, Sangal, Ramakrishnamacharyulu, 1995</marker>
<rawString>Akshar Bharati, Vineet Chaitanya, Rajeev Sangal, and KV Ramakrishnamacharyulu. 1995. Natural language processing: a Paninian perspective. Prentice-Hall of India New Delhi.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Riyaz Ahmad Bhat</author>
<author>Dipti Misra Sharma</author>
</authors>
<title>A dependency treebank of urdu and its evaluation.</title>
<date>2012</date>
<booktitle>In Proceedings of the Sixth Linguistic Annotation Workshop,</booktitle>
<pages>157--165</pages>
<publisher>Association</publisher>
<institution>for Computational Linguistics.</institution>
<contexts>
<context position="8816" citStr="Bhat and Sharma (2012)" startWordPosition="1429" endWordPosition="1432">e token playing and the lemma play would be [d 1, d 2, d 3]. By this, playing - play and crying - cry have the same class label, because they have the common suffix -ing. 4 Experiments Experiments were conducted for 4 ILs, viz. Hindi, Urdu, Telugu and Tamil. For Hindi, the Hindi Treebank (HTB) released as part of the 2012 Hindi Parsing Shared Task (Sharma et al., 2012) was used for the ML task. The statistical models were tuned on development data and evaluated on test data. Table 1. shows the HTB statistics. For Urdu, the Urdu Treebank (UTB) released as a part of the 2012 Proceedings of TLT (Bhat and Sharma (2012)) was used for evaluation. Table 2. represents the UTB statistics. For Telugu, the Telugu Treebank (TTB) released for ICON 2010 Shared Task (Husain et al. (2010)) was used for evaluation. Table 3. represents the TTB statistics. For Tamil, the Tamil Treebank (TaTB) released by the The Indian Languages Machine Translation (ILMT)10 project was used for evaluation. Table 4. represents the TaTB statistics. Data #Sentences #Words Training 12,041 268,096 Development 1,233 26,416 Test 1,828 39,775 Table 1: HTB Statistics. Data #Sentences #Words Training 5,700 159,743 Test 1,453 39,803 Table 2: UTB Sta</context>
</contexts>
<marker>Bhat, Sharma, 2012</marker>
<rawString>Riyaz Ahmad Bhat and Dipti Misra Sharma. 2012. A dependency treebank of urdu and its evaluation. In Proceedings of the Sixth Linguistic Annotation Workshop, pages 157–165. Association for Computational Linguistics.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Tina B¨ogel</author>
<author>Miriam Butt</author>
<author>Annette Hautli</author>
<author>Sebastian Sulger</author>
</authors>
<title>Developing a finite-state morphological analyzer for urdu and hindi.</title>
<date>2007</date>
<booktitle>Finite State Methods and Natural Language Processing, page 86. Grzegorz Chrupała, Georgiana Dinu, and Josef</booktitle>
<marker>B¨ogel, Butt, Hautli, Sulger, 2007</marker>
<rawString>Tina B¨ogel, Miriam Butt, Annette Hautli, and Sebastian Sulger. 2007. Developing a finite-state morphological analyzer for urdu and hindi. Finite State Methods and Natural Language Processing, page 86. Grzegorz Chrupała, Georgiana Dinu, and Josef Van Genabith. 2008. Learning morphology with morfette.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Grzegorz Chrupała</author>
</authors>
<title>Simple data-driven contextsensitive lemmatization.</title>
<date>2006</date>
<booktitle>Procesamiento del Lenguaje Natural,</booktitle>
<pages>37--121</pages>
<contexts>
<context position="7086" citStr="Chrupała (2006)" startWordPosition="1121" endWordPosition="1122">nouns have another set. To capture such information we included POS in the feature-set. (v) Other features : Features such as length of the token and character types in the token (eg. numbers, alphabets and so on) have also been considered. The Support Vector Machine (SVM) (using linear classifier) was used for the ML task . 3.2 Choosing Class Labels For the ML task, the class-labels for G, N, P, C were chosen from the training data itself. For lemma, the class-labels were formed based on the edit-distance8 operations required to convert the given token to its lemma. This idea was inspired by Chrupała (2006), who introduced the concept of edit-operations9 for lemmatization. The Algorithm is explained using an example. Consider the token crying. The lemma for crying is cry. Step 1: The token and its lemma are reversed. crying becomes gniyrc and cry becomes yrc. Step 2: Note the edit operations required to convert reversed token to the reversed lemma. To convert gniyrc to yrc we need to delete the characters at the 1st, 2nd and 3rd indices. Hence the edit operations would be [d 1, d 2, d 3], where ’d’ represents delete operation. Step 3: The set of edit operations would form the class-label. [d 1, </context>
</contexts>
<marker>Chrupała, 2006</marker>
<rawString>Grzegorz Chrupała. 2006. Simple data-driven contextsensitive lemmatization. Procesamiento del Lenguaje Natural, 37:121–127.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Vishal Goyal</author>
<author>Gurpreet Singh Lehal</author>
</authors>
<title>Hindi morphological analyzer and generator.</title>
<date>2008</date>
<booktitle>In Emerging Trends in Engineering and Technology,</booktitle>
<pages>1156--1159</pages>
<publisher>IEEE.</publisher>
<contexts>
<context position="2709" citStr="Goyal and Lehal (2008)" startWordPosition="404" endWordPosition="407">Gramatically, there are many similarities. Indian languages are synthetic5; derivational and inflectional morphologies result in the formation of complex words by stringing two or more morphemes. ILs predominantly have subject-object-verb (SOV) word order. They show agreement6 among words. We captured such type of characteristics, by building a robust feature set. 2 Related Work Traditionally, morphological analysis for Indian languages has been done using the rule based approach. For Hindi, the MA by Bharati et al. (1995) is most widely used among the NLP researchers in the Indian Community. Goyal and Lehal (2008) and Kanuparthi et al. (2012) MAs are advanced versions of the Bharati et al. (1995)’s analyzer. Kanuparthi et al. (2012) built a derivational MA for Hindi by introducing a layer over the Bharati et al. (1995)’s MA .It identifies 22 derivational suffixes which help in providing derivational analysis for the word whose suffix matches with one of these 22 suffixes. 1The Indic languages are the dominant language family of the Indian subcontinent, generally spoken in the regions of northern India and Pakistan 2The Dravidian languages are spoken mainly in southern India 3Vibhakti is a Sanskrit gram</context>
</contexts>
<marker>Goyal, Lehal, 2008</marker>
<rawString>Vishal Goyal and Gurpreet Singh Lehal. 2008. Hindi morphological analyzer and generator. In Emerging Trends in Engineering and Technology, 2008. ICETET’08. First International Conference on, pages 1156–1159. IEEE.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Samar Husain</author>
<author>Prashanth Mannem</author>
<author>Bharat Ram Ambati</author>
<author>Phani Gadde</author>
</authors>
<title>The icon-2010 tools contest on indian language dependency parsing.</title>
<date>2010</date>
<booktitle>Proceedings of ICON-2010 Tools Contest on Indian Language Dependency Parsing, ICON,</booktitle>
<pages>10--1</pages>
<contexts>
<context position="8977" citStr="Husain et al. (2010)" startWordPosition="1455" endWordPosition="1458">x -ing. 4 Experiments Experiments were conducted for 4 ILs, viz. Hindi, Urdu, Telugu and Tamil. For Hindi, the Hindi Treebank (HTB) released as part of the 2012 Hindi Parsing Shared Task (Sharma et al., 2012) was used for the ML task. The statistical models were tuned on development data and evaluated on test data. Table 1. shows the HTB statistics. For Urdu, the Urdu Treebank (UTB) released as a part of the 2012 Proceedings of TLT (Bhat and Sharma (2012)) was used for evaluation. Table 2. represents the UTB statistics. For Telugu, the Telugu Treebank (TTB) released for ICON 2010 Shared Task (Husain et al. (2010)) was used for evaluation. Table 3. represents the TTB statistics. For Tamil, the Tamil Treebank (TaTB) released by the The Indian Languages Machine Translation (ILMT)10 project was used for evaluation. Table 4. represents the TaTB statistics. Data #Sentences #Words Training 12,041 268,096 Development 1,233 26,416 Test 1,828 39,775 Table 1: HTB Statistics. Data #Sentences #Words Training 5,700 159,743 Test 1,453 39,803 Table 2: UTB Statistics. Data #Sentences #Words Training 1300 5125 Test 150 600 Table 3: TTB Statistics. 10This consortium project is funded by Ministry of Communication and Inf</context>
</contexts>
<marker>Husain, Mannem, Ambati, Gadde, 2010</marker>
<rawString>Samar Husain, Prashanth Mannem, Bharat Ram Ambati, and Phani Gadde. 2010. The icon-2010 tools contest on indian language dependency parsing. Proceedings of ICON-2010 Tools Contest on Indian Language Dependency Parsing, ICON, 10:1–8.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Nikhil Kanuparthi</author>
<author>Abhilash Inumella</author>
<author>Dipti Misra Sharma</author>
</authors>
<title>Hindi derivational morphological analyzer.</title>
<date>2012</date>
<booktitle>In Proceedings of the Twelfth Meeting of the Special Interest Group on Computational Morphology and Phonology,</booktitle>
<pages>10--16</pages>
<publisher>Association</publisher>
<institution>for Computational Linguistics.</institution>
<contexts>
<context position="2738" citStr="Kanuparthi et al. (2012)" startWordPosition="409" endWordPosition="412">y similarities. Indian languages are synthetic5; derivational and inflectional morphologies result in the formation of complex words by stringing two or more morphemes. ILs predominantly have subject-object-verb (SOV) word order. They show agreement6 among words. We captured such type of characteristics, by building a robust feature set. 2 Related Work Traditionally, morphological analysis for Indian languages has been done using the rule based approach. For Hindi, the MA by Bharati et al. (1995) is most widely used among the NLP researchers in the Indian Community. Goyal and Lehal (2008) and Kanuparthi et al. (2012) MAs are advanced versions of the Bharati et al. (1995)’s analyzer. Kanuparthi et al. (2012) built a derivational MA for Hindi by introducing a layer over the Bharati et al. (1995)’s MA .It identifies 22 derivational suffixes which help in providing derivational analysis for the word whose suffix matches with one of these 22 suffixes. 1The Indic languages are the dominant language family of the Indian subcontinent, generally spoken in the regions of northern India and Pakistan 2The Dravidian languages are spoken mainly in southern India 3Vibhakti is a Sanskrit grammatical term that encompasses</context>
</contexts>
<marker>Kanuparthi, Inumella, Sharma, 2012</marker>
<rawString>Nikhil Kanuparthi, Abhilash Inumella, and Dipti Misra Sharma. 2012. Hindi derivational morphological analyzer. In Proceedings of the Twelfth Meeting of the Special Interest Group on Computational Morphology and Phonology, pages 10–16. Association for Computational Linguistics.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Deepak Kumar Malladi</author>
<author>Prashanth Mannem</author>
</authors>
<title>Context based statistical morphological analyzer and its effect on hindi dependency parsing.</title>
<date>2013</date>
<booktitle>In Fourth Workshop on Statistical Parsing of Morphologically Rich Languages,</booktitle>
<volume>12</volume>
<pages>119</pages>
<contexts>
<context position="673" citStr="Malladi and Mannem (2013)" startWordPosition="85" endWordPosition="88">nguages Saikrishna Srirampur Ravi Chandibhamar Radhika Mamidi IIIT Hyderabad IIIT Hyderabad IIIT Hyderabad saikrishna.srirampur chandibhamar.ravi radhika.mamidi @research.iiit.ac.in @students.iiit.ac.in @iiit.ac.in Abstract Statistical morph analyzers have proved to be highly accurate while being comparatively easier to maintain than rule based approaches. Our morph analyzer (SMA++) is an improvement over the statistical morph analyzer (SMA) described in Malladi and Mannem (2013). SMA++ predicts the gender, number, person, case (GNPC) and the lemma (L) of a given token. We modified the SMA in Malladi and Mannem (2013), by adding some rich machine learning features. The feature set was chosen specifically to suit the characteristics of Indian Languages. In this paper we apply SMA++ to four Indian languages viz. Hindi, Urdu, Telugu and Tamil. Hindi and Urdu belong to the Indic1 language family. Telugu and Tamil belong to the Dravidian2 language family. We compare SMA++ with some state-of-art statistical morph analyzers viz. Morfette in Chrupała et al. (2008) and SMA in Malladi and Mannem (2013). In all four languages, our system performs better than the above mentioned state-of-art SMAs. 1 Introduction Morph</context>
<context position="4262" citStr="Malladi and Mannem (2013)" startWordPosition="647" endWordPosition="650"> or Concord happens when a word changes form depending on the other words to which it relates This work is licenced under a Creative Commons Attribution 4.0 International License. Page numbers and proceedings footer 103 are added by the organizers. License details: http://creativecommons.org/licenses/by/4.0/ Proceedings of the First Workshop on Applying NLP Tools to Similar Languages, Varieties and Dialects, pages 103–109, Dublin, Ireland, August 23 2014. There have not been many updates in the rule based analyzers and the problem of not predicting OOV words is still a significant one. SMA in Malladi and Mannem (2013) is a data-driven MA which focuses primarily on Hindi. For Urdu, B¨ogel et al. (2007) proposes an approach which uses Finite State Transducers. It introduces and discusses the issues that arise in the process of building finite-state MA for Urdu. For Telugu, Sunitha and Kalyani (2009) propose an approach of improving the existing rule based Telugu MA. They did this, using possible decompositions of the word, inflected by many morphemes. SMA in Malladi and Mannem (2013) evaluates the results for Urdu and Telugu as well. Not much research has been done in Morphological Analysis for Tamil. 3 Our </context>
<context position="10205" citStr="Malladi and Mannem (2013)" startWordPosition="1652" endWordPosition="1656">ation Technology, Technology Development for Indian Languages, Government Of India. 105 Data #Sentences #Words Training 75 682 Test 25 271 Table 4: TaTB Statistics. 5 Results The feature-set, which was specifically chosen for ILs, contributed to high accuracies. The results are shown for 4 Indian Languages. The results for each of L, G, N, P and C are shown individually, as well as in combination. 5.1 Hindi The results are presented all five L ,G, N, P and C. The results are compared to 3 MAs viz. the traditional Rule Based MA (RBA) for Hindi, Morfette (M) in Chrupała et al. (2008) and SMA in Malladi and Mannem (2013) (SMA-M). There are two divisions for results. One for the Overall test data and other for the Out of Vocabulary (OOV) test data. SMA++ out performed other three MAs in almost all combinations. The results for OOV data are more pronounced. Table 5. shows the Hindi results. Analysis Test Data - Overall (%) Test Data - OOV (%) RBA M SMA-M SMA++ RBA M SMA-M SMA++ L 86.69 94.14 95.84 98.43 82.48 90.30 89.51 93.07 G 79.59 95.05 96.19 96.21 44.06 72.03 82.65 83.11 N 80.50 94.09 95.37 95.47 47.56 84.89 90.44 92.81 P 84.13 94.88 96.38 96.28 53.89 84.76 94.85 96.17 C 81.20 93.91 95.32 95.43 47.36 80.21</context>
<context position="12351" citStr="Malladi and Mannem (2013)" startWordPosition="2046" endWordPosition="2049">86.56 98.39 C 87.99 90.92 76.08 84.07 L+C 82.94 86.93 67.25 75.66 G+N+P 84.52 89.43 70.32 86.09 G+N+P+C 77.01 82.17 58.54 73.69 L+G+N+P 80.12 86.07 64.14 78.93 L+G+N+P+C 73.11 79.16 53.30 67.98 Table 6: Urdu Results for SMA++ and M Analysis Test Data - Overall (%) Test Data - OOV (%) SMA-M SMA++ SMA-M SMA++ G 89.14 93.79 88.18 90.35 N 91.62 95.66 91.35 94.50 P 93.37 97.07 95.53 98.39 C 85.49 90.92 79.01 84.07 Table 7: Urdu Results for SMA++ and SMA-M 5.3 Telugu The results are presented for G, N, P and C. The results are compared to 2 MAs viz. Morfette (M) in Chrupała et al. (2008) and SMA in Malladi and Mannem (2013) (SMA-M). Results are presented for both Overall test data and OOV test data. SMA++ significantly out performed Morfette (M). The results of Overall Data for SMA++ and SMA-M are very close, but more importantly the results of OOV data for SMA++ are higher than SMA-M. Table 8. presents the results in comparison with Morfette (M) and Table 9. presents the results in comparison with SMA-M. Analysis Test Data - Overall (%) Test Data - OOV (%) M SMA++ M SMA++ G 95.49 96.33 87.82 89.85 N 87.31 90.48 65.48 77.67 P 94.49 94.49 86.80 86.80 C 94.49 95.66 84.26 90.36 G+N+P 85.48 88.81 60.91 74.62 G+N+P+C</context>
</contexts>
<marker>Malladi, Mannem, 2013</marker>
<rawString>Deepak Kumar Malladi and Prashanth Mannem. 2013. Context based statistical morphological analyzer and its effect on hindi dependency parsing. In Fourth Workshop on Statistical Parsing of Morphologically Rich Languages, volume 12, page 119.</rawString>
</citation>
<citation valid="true">
<date>2012</date>
<booktitle>Proceedings of the Workshop on Machine Translation and Parsing in Indian Languages. The COLING 2012 Organizing Committee,</booktitle>
<editor>Dipti Misra Sharma, Prashanth Mannem, Joseph vanGenabith, Sobha Lalitha Devi, Radhika Mamidi, and Ranjani Parthasarathi, editors.</editor>
<location>Mumbai, India,</location>
<contexts>
<context position="2738" citStr="(2012)" startWordPosition="412" endWordPosition="412">dian languages are synthetic5; derivational and inflectional morphologies result in the formation of complex words by stringing two or more morphemes. ILs predominantly have subject-object-verb (SOV) word order. They show agreement6 among words. We captured such type of characteristics, by building a robust feature set. 2 Related Work Traditionally, morphological analysis for Indian languages has been done using the rule based approach. For Hindi, the MA by Bharati et al. (1995) is most widely used among the NLP researchers in the Indian Community. Goyal and Lehal (2008) and Kanuparthi et al. (2012) MAs are advanced versions of the Bharati et al. (1995)’s analyzer. Kanuparthi et al. (2012) built a derivational MA for Hindi by introducing a layer over the Bharati et al. (1995)’s MA .It identifies 22 derivational suffixes which help in providing derivational analysis for the word whose suffix matches with one of these 22 suffixes. 1The Indic languages are the dominant language family of the Indian subcontinent, generally spoken in the regions of northern India and Pakistan 2The Dravidian languages are spoken mainly in southern India 3Vibhakti is a Sanskrit grammatical term that encompasses</context>
<context position="8816" citStr="(2012)" startWordPosition="1432" endWordPosition="1432">and the lemma play would be [d 1, d 2, d 3]. By this, playing - play and crying - cry have the same class label, because they have the common suffix -ing. 4 Experiments Experiments were conducted for 4 ILs, viz. Hindi, Urdu, Telugu and Tamil. For Hindi, the Hindi Treebank (HTB) released as part of the 2012 Hindi Parsing Shared Task (Sharma et al., 2012) was used for the ML task. The statistical models were tuned on development data and evaluated on test data. Table 1. shows the HTB statistics. For Urdu, the Urdu Treebank (UTB) released as a part of the 2012 Proceedings of TLT (Bhat and Sharma (2012)) was used for evaluation. Table 2. represents the UTB statistics. For Telugu, the Telugu Treebank (TTB) released for ICON 2010 Shared Task (Husain et al. (2010)) was used for evaluation. Table 3. represents the TTB statistics. For Tamil, the Tamil Treebank (TaTB) released by the The Indian Languages Machine Translation (ILMT)10 project was used for evaluation. Table 4. represents the TaTB statistics. Data #Sentences #Words Training 12,041 268,096 Development 1,233 26,416 Test 1,828 39,775 Table 1: HTB Statistics. Data #Sentences #Words Training 5,700 159,743 Test 1,453 39,803 Table 2: UTB Sta</context>
</contexts>
<marker>2012</marker>
<rawString>Dipti Misra Sharma, Prashanth Mannem, Joseph vanGenabith, Sobha Lalitha Devi, Radhika Mamidi, and Ranjani Parthasarathi, editors. 2012. Proceedings of the Workshop on Machine Translation and Parsing in Indian Languages. The COLING 2012 Organizing Committee, Mumbai, India, December.</rawString>
</citation>
<citation valid="true">
<authors>
<author>KVN Sunitha</author>
<author>N Kalyani</author>
</authors>
<title>A novel approach to improve rule based telugu morphological analyzer.</title>
<date>2009</date>
<booktitle>In Nature &amp; Biologically Inspired Computing,</booktitle>
<pages>1649--1652</pages>
<publisher>IEEE.</publisher>
<contexts>
<context position="4547" citStr="Sunitha and Kalyani (2009)" startWordPosition="693" endWordPosition="696">mons.org/licenses/by/4.0/ Proceedings of the First Workshop on Applying NLP Tools to Similar Languages, Varieties and Dialects, pages 103–109, Dublin, Ireland, August 23 2014. There have not been many updates in the rule based analyzers and the problem of not predicting OOV words is still a significant one. SMA in Malladi and Mannem (2013) is a data-driven MA which focuses primarily on Hindi. For Urdu, B¨ogel et al. (2007) proposes an approach which uses Finite State Transducers. It introduces and discusses the issues that arise in the process of building finite-state MA for Urdu. For Telugu, Sunitha and Kalyani (2009) propose an approach of improving the existing rule based Telugu MA. They did this, using possible decompositions of the word, inflected by many morphemes. SMA in Malladi and Mannem (2013) evaluates the results for Urdu and Telugu as well. Not much research has been done in Morphological Analysis for Tamil. 3 Our Approach 3.1 Feature Set The feature-set was chosen specifically to suit the Indian Languages. The following are the features used: (i) Suffixes : Indian languages show inflectional morphology. The inflectional morphemes carry the G,N,P and C of a word. These morphemes generally occur</context>
</contexts>
<marker>Sunitha, Kalyani, 2009</marker>
<rawString>KVN Sunitha and N Kalyani. 2009. A novel approach to improve rule based telugu morphological analyzer. In Nature &amp; Biologically Inspired Computing, 2009. NaBIC 2009. World Congress on, pages 1649–1652. IEEE.</rawString>
</citation>
</citationList>
</algorithm>
</algorithms>